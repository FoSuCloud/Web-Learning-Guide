## arr.splice(1,1,1)===[x]
1. 数组使用splice方法返回的是删除的部分数组,splice三个参数分别表示索引(必须),删除个数(必须),添加的元素
2. splice方法用法:
```
			var arr=[1,2,3];
			console.log(arr.splice(1,1,1));//[2]
			console.log(arr);//[1,1,3]
			console.log(arr.splice(1,0,2));//第二个参数为0表示不删除元素
			console.log(arr);//[1,2,1,3],2直接插入到下标为1的元素处
			console.log(arr.splice(1,0,2,3,4));
			console.log(arr);//[1,2,3,4,2,1,3]第三个参数可以是多个参数,都插入到1的位置
```
3. 例子:`[1,1,3].splice(1,1,2)===[2]`
4. `对数组进行删除后，的确返回[2]这个数组，但是数组属于引用数据类型，对===除了值相等，还需要内存地址相等！`

## arr空数组直接赋值
1. 对于空数组来说，它的长度根据被赋值的最大数组下标元素决定，如果被赋值的最大下标元素是arr[5],那么数组长度就是6
2. 如果存在某些数组下标元素没有被赋值，那么那些元素就是`empty,也就是undefined`
```
			var arr=[];
			arr[0]=0;
			arr[3]=3;
			arr[5]=5;
			console.log(arr);
			console.log(arr.length);//6
			for(var i=0;i<arr.length;i++){
				console.log(arr[i]);//存在undefined
			}
```

## 微任务宏任务执行顺序
```
		console.log('1');
			// new Promise是异步微任务,在一个执行循环结束后执行
			new Promise(function(resolve,reject){
				console.log('2');
				setTimeout(function(){
					console.log('5');
					// resolve('success');//此时先打印5再去打印4
				},0);
				resolve('success');//此时先执行then,console.log('4')再去执行5
			}).then(()=>{
				console.log('4')
			})
			console.log('3');
			// setTimeout属于异步宏任务,在一次事件循环之后,如果有微任务先执行微任务,然后再来执行异步宏任务
			setTimeout(function(){
				console.log('6')
			},0)
```

## 数组sort方法有参数！
```
			var arr=[3,5,1,7,4];
			console.log(arr.sort());//默认升序排序[1,3,4,5,7]
			console.log(arr);//sort排序方法能够改变原数组
			//需要注意的是,sort方法其实是可以有一个参数的,该参数必须是函数
			//如果给sort方法指定函数,那么根据函数对数组里面的值进行两两比较,如果大于0,那么就颠倒顺序
			function del(a,b){
				return b-a;//自定义一个降序排序的函数
			}
			console.log(arr.sort(del));//[7,5,3,1]
```

## 获取字符串长度
```
如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1
否则如果字符 Unicode 编码 > 255 则长度为 2

			function strLength(s, bUnicode255For1) {
				var num=0;
				for(var i=0;i<s.length;i++){
					if(s.charCodeAt(i)>255&&!bUnicode255For1){
						num+=2;
					}else{
						num+=1;
					}
				}
				return num;
			}
			console.log(strLength('hello world, 牛客', true))
```

## 统计字符串频率
```
统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率
1. 不限制 key 的顺序
2. 输入的字符串参数不会为空
3. 忽略空白字符

function count(str) {
    var obj={};
    var arr=str.split("");

    arr.forEach((item)=>{
        if(obj[item]==undefined&&item!=' '){
            obj[item]=1;
        }
        else if(obj[item]>0){
            obj[item]+=1;
        }
    })
    return obj;
}
```

## 在不直接修改数组的前提下，给数组头部添加一个元素
1. slice(0)表示从0也就是第一个元素开始选取，第二个参数不设置就是选取所有元素，然后返回选取的子数组(与原来数组不一样)
```
var new_arr=arr.slice(0);//值相等的子数组
new_arr.unshift(item);
```
2. 使用[]与concat生成新数组
```
[item].concat(arr);
```

## 删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组
1. `return arr.slice(1);`
2. 使用filter过滤器
```
return arr.filter((item,index)=>{
        if(index!=0) return true;
    })
	把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
```

## 合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组
1. `return arr1.slice(0).concat(arr2)`
2. `return arr1.concat().concat(arr2); arr1.concat()返回的是一个新的数组，不是浅拷贝之后的数组`

## 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组
1. 使用concat/slice 和splice(index,0,item)
```
    var new_arr=arr.concat();
    new_arr.splice(index,0,item);
    return new_arr;
```
2. 通过index来巧妙的设置slice,concat
```
return arr.slice(0,index).concat([item]).concat(arr.slice(index))
```

## 统计数组 arr 中值等于 item 的元素出现的次数
1. 通过map来统计符合条件的元素
```
    var num=0;
    arr.map((it)=>{
        if(item==it){
            num++;
        }
    })
    return num;
```
2. 通过filter来获取符合条件的数组
```
    var new_arr=arr.filter((it)=>{
        if(it==item) return true;
    });//filter不会改变原数组
    return new_arr.length;
```

## 找出数组 arr 中重复出现过的元素
1. 通过indexOf(item,index+1)与新数组中是否有该元素
```
			    var new_arr=[];
			    arr.filter((item,index)=>{
			        if(arr.indexOf(item,index+1)!=-1&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
			            return true;
			        }
			    })
			    return new_arr;
```
2. 通过filter,新数组,lastIndexOf,indexOf来判断
```
			    var new_arr=[]
				arr.filter((item)=>{
			        if(arr.indexOf(item)!=arr.lastIndexOf(item)&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
						return false;
			        }else{
						return true;
					}
			    })
			    return new_arr;
```
3. 先排序，sort会直接改变原数组，然后再判断下一个元素是否等于本元素，注意数组越界
```
				arr.sort();
				var new_arr=[];
				arr.filter((item,index)=>{
					if(index<arr.length&&item==arr[index+1]&&new_arr.indexOf(item)==-1){
						new_arr.push(item)
						return true;
					}
				})
				return new_arr;
```

## 为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组
1. 使用map
```
			    return arr.map((item)=>{
			        return Math.pow(item,2)
			    })
```
2. 使用forEach
```
				arr.forEach((item,index)=>{
					arr[index]=Math.pow(item,2)
				})
				return arr
```
3. 使用filter
```
				arr.filter((item,index)=>{
					arr[index]=Math.pow(item,2);
					return true;
				})
				return arr
```

## 获取本周的月日
```
			  function getWeek(){
				// 一周
				var arr = [];  // 周一开始
				var newdate = new Date('2019-11-14')
				var now_day=newdate.getDate();
				var now = newdate.getTime();
				var month=newdate.getMonth()+1;
				var day = newdate.getDay();    // 星期
				var oneDayTime = 60 * 60 * 24 * 1000;
				for (var i = 1; i < 8; i++) {
				  if (day >= i) {
					var dd = new Date(now - (day - i) * oneDayTime).getDate();
					if(now_day<dd){
						arr.push((month-1)+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}else{
						arr.push(month+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}
				  } else {
					var aa = new Date(now + (i - day) * oneDayTime).getDate();
					if(now_day>aa){
						arr.push((month)+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}else{
						arr.push(month+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}
				  }
				}
				return arr;
			  };
```

## 判断当前日期为当年第几周
```
			  function getYearWeek(a, b, c) {
			      //date1是当前日期 (需要注意的是month的索引从开始，所以需要减一)
			      //date2是当年第一天
			      //d是当前日期是今年第多少天
			      //用d + 当前年的第一天的周差距的和在除以7就是本年第几周
				  // 此处的valueOf其实相等于getTime获取时间戳
			      var date1 = new Date(a, parseInt(b) - 1, c), date2 = new Date(a, 0, 1),
			          d = Math.round((date1.valueOf() - date2.valueOf()) / 86400000);
			      return Math.ceil((d + date2.getDay()+1) / 7);
				  //(d + date2.getDay()+1)的存在是因为该年的第一天可能不是周一，而且要修改为周日为每周起始，所以+1，所以要获取该年第一天是周几，对应增加
			  };
			  console.log(getYearWeek(2019,1,6));//此时就是第二周了！
```

## 在数组 arr 中，查找值与 item 相等的元素出现的所有位置
```
			function findAllOccurrences(arr, target) {
			    var new_arr=[];
			    while(arr.indexOf(target)!=-1){
			        var index=arr.indexOf(target);
			        new_arr.push(index);
			        arr.splice(index,1,null);
					console.log(arr)
			    }
			    return new_arr;
			}
```
* `arr.splice(index,1,null);表示从索引为index的位置开始删除一个元素，然后在该位置添加一个元素为null`

## 全局变量
* `在Javascript语言中，声明变量使用的都是关键字var，如果不使用var而直接声明变量，则该变量为全局变量。`
```
function globals() {
    var myObject = {
      name : 'Jory'
    };
	//如果不使用var,那么myObject就是全局变量
    return myObject;
}
```
* 滥用全局变量的缺点
```
			var  one='global'
			function global(){
				one='private';
				//没有使用var声明变量,那么默认为全局变量
				return one;
			}
			console.log(one);//global 
			console.log(global());//执行函数,修改了全局变量one,结果为private 
			console.log(one);//private 
```

## 修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例
```
function parse2Int(num) {
    var reg=new RegExp(/\D/ig);
    var reg_num=num.search(reg);
    return reg_num==-1?parseInt(num):parseInt(num.slice(0,reg_num));
}
```
* 看到大佬的解法是`parseInt(num,10)`
```
看到还有一种解法，很巧妙，因为parseInt(string/Number,axis)方法是有两个参数的，（虽然我们一般只用一个参数），第一个参数是字符串，parseInt方法解析第一个参数是从第一个字符开始直到第一个不是数字的字符，如果第一个字符就不是数字，那么就返回NaN。
第二个参数是使用的进制，但是如果第一个参数不是字符串而是直接使用数字Number，例如parseInt(0x12,10),那么这时候就是16+2=18，而不是0了，因为第一个参数优先级高于第二个参数，此时第二个参数即使设置了进制也不生效.
看到大佬的解法就是使用parseInt(str,10)，因为该题目第一个参数肯定是字符串，所以最后都是把第一个参数的第一个数字部分截取出来再去转为10进制
```

## 计时器
1. 题目
```
实现一个打点计时器，要求
1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1
2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作
3、第一个数需要立即输出
```
2. `该题目有点毛病？虽然实现了，但是我觉得很鸡肋，即使函数多了个cancel方法，但是一执行该方法，之前设置的数字哟有什么意义？因为一执行该方法，计时器就会停止`
```
			function count(start, end) {
			    console.log(start);
			    var time=setInterval(()=>{
			        if(start<end){
						start+=1;
						console.log(start);
					}
			    },100)
				return {cancel:function(){
					clearInterval(time)
				}};
			}
			count(1,3).cancel()
```

## 加号运算符优先级低于括号，高于三目运算符
```
			// var val=1;
			var val=0;
			console.log('加号优先级高于三目运算符'+(val!=0)?'true':'false')
			//无论val为何值，最后都是true,因为此时执行完括号内容就执行加号内容
			//执行完加号后"'加号优先级高于三目运算符'+(val!=0)"就肯定是字符串，肯定为true了！三目运算符就肯定是true
```

## 布尔值与布尔对象
```
			var x=new Boolean(0);//布尔对象
			var y=Boolean(0);//布尔值
			if(x){//因为x是布尔对象,而所有对象转为布尔值都是true,if语句中需要的是转换为布尔值的结果,所以Boolean{false}转为布尔值true,结果为true
				console.log(x);//Boolean{false}
			}
			if(y){
				console.log(y);//不打印
			}
			console.log(y);//false,这是布尔值
```

## 变量回收
1. 变量回收规则:`全局变量不会被回收`,`局部变量会被回收，也就是函数一运行完毕，里面的变量就被销毁`,`与第二条规则对应的是，如果作用域被另外一个作用域所引用，那么被引用的变量不会被回收`
```
	var i = 1;
	var i = 2;//对i变量的第二次声明被忽略了，但是对i变量成功重新赋值了
	//而i变量是全局变量，根据第一条规则，全局变量不会被回收
	//需要注意的是,var add的add也是全局变量，根据第一条规则，add变量也不会被回收
	var add = function() {
		var i = 0;//根据第二条规则，局部变量在函数执行完毕之后应该被回收了，但是根据第三条规则，该函数返回了一个函数形成了闭包，
		//此处的变量i被别的作用域所引用，所以变量i也没有被回收，所以共有3个变量没有被回收
		return function()
		{
			i++;
			console.log(i);
		}
	}();
	add();
```
