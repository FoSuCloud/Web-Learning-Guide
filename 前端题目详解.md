## arr.splice(1,1,1)===[x]
1. 数组使用splice方法返回的是删除的部分数组,splice三个参数分别表示索引(必须),删除个数(必须),添加的元素
2. splice方法用法:
```
			var arr=[1,2,3];
			console.log(arr.splice(1,1,1));//[2]
			console.log(arr);//[1,1,3]
			console.log(arr.splice(1,0,2));//第二个参数为0表示不删除元素
			console.log(arr);//[1,2,1,3],2直接插入到下标为1的元素处
			console.log(arr.splice(1,0,2,3,4));
			console.log(arr);//[1,2,3,4,2,1,3]第三个参数可以是多个参数,都插入到1的位置
```
3. 例子:`[1,1,3].splice(1,1,2)===[2]`
4. `对数组进行删除后，的确返回[2]这个数组，但是数组属于引用数据类型，对===除了值相等，还需要内存地址相等！`

## arr空数组直接赋值
1. 对于空数组来说，它的长度根据被赋值的最大数组下标元素决定，如果被赋值的最大下标元素是arr[5],那么数组长度就是6
2. 如果存在某些数组下标元素没有被赋值，那么那些元素就是`empty,也就是undefined`
```
			var arr=[];
			arr[0]=0;
			arr[3]=3;
			arr[5]=5;
			console.log(arr);
			console.log(arr.length);//6
			for(var i=0;i<arr.length;i++){
				console.log(arr[i]);//存在undefined
			}
```

## 微任务宏任务执行顺序
```
		console.log('1');
			// new Promise是异步微任务,在一个执行循环结束后执行
			new Promise(function(resolve,reject){
				console.log('2');
				setTimeout(function(){
					console.log('5');
					// resolve('success');//此时先打印5再去打印4
				},0);
				resolve('success');//此时先执行then,console.log('4')再去执行5
			}).then(()=>{
				console.log('4')
			})
			console.log('3');
			// setTimeout属于异步宏任务,在一次事件循环之后,如果有微任务先执行微任务,然后再来执行异步宏任务
			setTimeout(function(){
				console.log('6')
			},0)
```

## 数组sort方法有参数！
```
			var arr=[3,5,1,7,4];
			console.log(arr.sort());//默认升序排序[1,3,4,5,7]
			console.log(arr);//sort排序方法能够改变原数组
			//需要注意的是,sort方法其实是可以有一个参数的,该参数必须是函数
			//如果给sort方法指定函数,那么根据函数对数组里面的值进行两两比较,如果大于0,那么就颠倒顺序
			function del(a,b){
				return b-a;//自定义一个降序排序的函数
			}
			console.log(arr.sort(del));//[7,5,3,1]
```

## 获取字符串长度
```
如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1
否则如果字符 Unicode 编码 > 255 则长度为 2

			function strLength(s, bUnicode255For1) {
				var num=0;
				for(var i=0;i<s.length;i++){
					if(s.charCodeAt(i)>255&&!bUnicode255For1){
						num+=2;
					}else{
						num+=1;
					}
				}
				return num;
			}
			console.log(strLength('hello world, 牛客', true))
```

## 统计字符串频率
```
统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率
1. 不限制 key 的顺序
2. 输入的字符串参数不会为空
3. 忽略空白字符

function count(str) {
    var obj={};
    var arr=str.split("");

    arr.forEach((item)=>{
        if(obj[item]==undefined&&item!=' '){
            obj[item]=1;
        }
        else if(obj[item]>0){
            obj[item]+=1;
        }
    })
    return obj;
}
```

## 在不直接修改数组的前提下，给数组头部添加一个元素
1. slice(0)表示从0也就是第一个元素开始选取，第二个参数不设置就是选取所有元素，然后返回选取的子数组(与原来数组不一样)
```
var new_arr=arr.slice(0);//值相等的子数组
new_arr.unshift(item);
```
2. 使用[]与concat生成新数组
```
[item].concat(arr);
```

## 删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组
1. `return arr.slice(1);`
2. 使用filter过滤器
```
return arr.filter((item,index)=>{
        if(index!=0) return true;
    })
	把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
```

## 合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组
1. `return arr1.slice(0).concat(arr2)`
2. `return arr1.concat().concat(arr2); arr1.concat()返回的是一个新的数组，不是浅拷贝之后的数组`

## 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组
1. 使用concat/slice 和splice(index,0,item)
```
    var new_arr=arr.concat();
    new_arr.splice(index,0,item);
    return new_arr;
```
2. 通过index来巧妙的设置slice,concat
```
return arr.slice(0,index).concat([item]).concat(arr.slice(index))
```

## 统计数组 arr 中值等于 item 的元素出现的次数
1. 通过map来统计符合条件的元素
```
    var num=0;
    arr.map((it)=>{
        if(item==it){
            num++;
        }
    })
    return num;
```
2. 通过filter来获取符合条件的数组
```
    var new_arr=arr.filter((it)=>{
        if(it==item) return true;
    });//filter不会改变原数组
    return new_arr.length;
```

## 找出数组 arr 中重复出现过的元素
1. 通过indexOf(item,index+1)与新数组中是否有该元素
```
			    var new_arr=[];
			    arr.filter((item,index)=>{
			        if(arr.indexOf(item,index+1)!=-1&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
			            return true;
			        }
			    })
			    return new_arr;
```
2. 通过filter,新数组,lastIndexOf,indexOf来判断
```
			    var new_arr=[]
				arr.filter((item)=>{
			        if(arr.indexOf(item)!=arr.lastIndexOf(item)&&new_arr.indexOf(item)==-1){
			            new_arr.push(item)
						return false;
			        }else{
						return true;
					}
			    })
			    return new_arr;
```
3. 先排序，sort会直接改变原数组，然后再判断下一个元素是否等于本元素，注意数组越界
```
				arr.sort();
				var new_arr=[];
				arr.filter((item,index)=>{
					if(index<arr.length&&item==arr[index+1]&&new_arr.indexOf(item)==-1){
						new_arr.push(item)
						return true;
					}
				})
				return new_arr;
```

## 为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组
1. 使用map
```
			    return arr.map((item)=>{
			        return Math.pow(item,2)
			    })
```
2. 使用forEach
```
				arr.forEach((item,index)=>{
					arr[index]=Math.pow(item,2)
				})
				return arr
```
3. 使用filter
```
				arr.filter((item,index)=>{
					arr[index]=Math.pow(item,2);
					return true;
				})
				return arr
```

## 获取本周的月日
```
			  function getWeek(){
				// 一周
				var arr = [];  // 周一开始
				var newdate = new Date('2019-11-14')
				var now_day=newdate.getDate();
				var now = newdate.getTime();
				var month=newdate.getMonth()+1;
				var day = newdate.getDay();    // 星期
				var oneDayTime = 60 * 60 * 24 * 1000;
				for (var i = 1; i < 8; i++) {
				  if (day >= i) {
					var dd = new Date(now - (day - i) * oneDayTime).getDate();
					if(now_day<dd){
						arr.push((month-1)+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}else{
						arr.push(month+'-'+(dd < 10 ? '0' + dd : dd + ''));
					}
				  } else {
					var aa = new Date(now + (i - day) * oneDayTime).getDate();
					if(now_day>aa){
						arr.push((month)+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}else{
						arr.push(month+'-'+(aa < 10 ? '0' + aa : aa + ''));
					}
				  }
				}
				return arr;
			  };
```
