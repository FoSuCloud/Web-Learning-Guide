## referer
* 请求头的referer字段用来描述请求的来源。
* 测试的方式：
1、在一个网站添加一个a标签，在href属性添加localhost网址，然后点击链接，跳转
2、在一个网站添加一个img标签，添加src属性添加`window.location.href='http://localhost:3000'`，然后就会切换到对应的网址
3、直接添加一个button按钮，添加onclick事件，点击按钮，触发函数`window.open(http://localhost:3000)`,然后就会打开对应的网址
  
`但是注意一个很重要的点！`
`请求头有一个字段：Referrer Policy:strict-origin-when-cross-origin`
`这是因为来源网址是https协议，然后目标网址是http协议，那么就发生了协议降级，就不会显示referer了`
`因为违反了同源策略。`
`所以正确的测试方式有一个前提条件就是从http网址跳转到http网址`

## host和origin和referer的区别
1、host用于表示`服务端的主机ip地址，表示请求将要被发到哪里去`
2、origin用于`表示客户端的协议+域名，只在跨域的请求中才会在请求头带上，表示来源的地址`
3、referer用于`表示客户端的协议+域名+参数，但是参数不包括hash参数，也就是我们要使用history路由才能看到区别`
* 例子：一个`mode:history的vue项目，跳转到home页面，url为http://localhost:8080/home`
```javascript
// 8080的项目，请求3000端口的后端接口
Host: localhost:3000
Origin: http://localhost:8080
Referer: http://localhost:8080/home
```
* `注意，我们在vue.config.js通过配置proxy代理，把请求的地址代理到3000端口`
`所以我们在浏览器字段看到的Host：localhost:8080，但是在后端可以拿到Host:3000`
```javascript
// 注意，需要给vue.config.js配置changOrigin:true
// 这样才会改变来源的Host字段
devServer: {
    open: true,
        host: "0.0.0.0",
        port: 8080,
        https: false,
        hotOnly: true,
        proxy: {
        "/": {
            target: "http://localhost:3000/",
                changeOrigin: true, // 是否改变发送到后端的host字段，如果改变，那么host就是对应的target字段
        }
    }
}
```

### referer字段用途
* [https://juejin.cn/post/6844903954455724045]("参考")
* referer字段一般用在防盗链中，当我们在自己的网站使用别人网站的图片
* 那么别人网站会判断referer，如果我们的网站地址不在对方的白名单中，那么
* 对方会根据referer判断出我们的网址，就会拒绝发送图片资源给我们。

* referer会把前端地址栏的路径全部发送过去(除了锚点,hash这部分)，可能会包含敏感信息
* 而origin只包含协议+域名，不包含敏感信息，所以更加安全

## set-cookie
`vue项目使用的是history路由`
* set-cookie字段有以下几个值
1、key=value(字段和字段值)
2、expires(过期时间，如果不设置那么就是session,会话结束就清除cookie)
3、path:表示路径`一般使用/表示根目录，也就是表示我们这个cokkie可以被什么目录下的资源获取到`
4、domain表示域名，`默认是当前域名`
* 看一个例子，看一下domain的应用
```javascript
// 我们在localhost启动一个vue项目
// 然后后端返回domain:app.localhost
// 注意我们得domain字段第一个值必须是.,也就是一个点
// 另外不要使用双引号，直接用.
// node.js代码:
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/;domain=.app.localhost;HttpOnly')

// 然后我们在app.localhost网址可以访问到该cookie
// 在api.app.localhost和xxx.app.localhost都可以访问到该cookie
// 但是在localhost访问不到，也就是cookie的作用域是自己的子域，不包括父域
```

* 然后我们再看一个例子，看一下path
* `注意，set-cookie里面的值一定不要用双引号！！除了value和expires`
```javascript
// node.js
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/home')

// 然后我们前端打开/home网页
// 然后可以看到cookie的path为/home
// 然后打印document.cookie可以拿到值
// 但是在/根路径下无法获取cookie,这是因为我们设置了path,必须是home或者home的子目录才能拿到该cookie
```

* 另外还有两个属性
5、`HttpOnly表示只能被http请求所读取，不能被客户端所读取（控制台打印拿不到值）`
6、`secure表示只能通过https协议发送的请求才能使用该cookie；但是secure对应的cookie可以被客户端读写`
`所以一般secure和httpOnly配合使用更安全`
```javascript
// 首先我们在node后端设置set-cookie
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/;secure')

// 然后我们在前端可以拿到对应的值
// document.cookie
// a=\"aa\"

// 然后我们新增一个b的cookie
// document.cookie = "b='abc'"

// 我们再修改以下a这个cookie(secure的cookie也是可以读写的！)
// document.cookie = 'a="111";expires="Sun Jul 18 2022 10:31:45";path=/;secure'
// "a=\"111\";expires=\"Sun Jul 18 2022 10:31:45\";path=/;secure"
// document.cookie
// "b='abc'; a=\"111\""
```
* `注意，即使key相同，如果配置项不同，那么我们的cookie会存在同名的！`
* 例如存在一个httpOnly为true的a,一个为false的a;两个同时存在!

