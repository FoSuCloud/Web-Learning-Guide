## referer
* 请求头的referer字段用来描述请求的来源。
* 测试的方式：
1、在一个网站添加一个a标签，在href属性添加localhost网址，然后点击链接，跳转
2、在一个网站添加一个img标签，添加src属性添加`window.location.href='http://localhost:3000'`，然后就会切换到对应的网址
3、直接添加一个button按钮，添加onclick事件，点击按钮，触发函数`window.open(http://localhost:3000)`,然后就会打开对应的网址
  
`但是注意一个很重要的点！`
`请求头有一个字段：Referrer Policy:strict-origin-when-cross-origin`
`这是因为来源网址是https协议，然后目标网址是http协议，那么就发生了协议降级，就不会显示referer了`
`因为违反了同源策略。`
`所以正确的测试方式有一个前提条件就是从http网址跳转到http网址`

## host和origin和referer的区别
1、host用于表示`服务端的主机ip地址，表示请求将要被发到哪里去`
2、origin用于`表示客户端的协议+域名，只在跨域的请求中才会在请求头带上，表示来源的地址`
3、referer用于`表示客户端的协议+域名+参数，但是参数不包括hash参数，也就是我们要使用history路由才能看到区别`
* 例子：一个`mode:history的vue项目，跳转到home页面，url为http://localhost:8080/home`
```javascript
// 8080的项目，请求3000端口的后端接口
Host: localhost:3000
Origin: http://localhost:8080
Referer: http://localhost:8080/home
```
* `注意，我们在vue.config.js通过配置proxy代理，把请求的地址代理到3000端口`
`所以我们在浏览器字段看到的Host：localhost:8080，但是在后端可以拿到Host:3000`
```javascript
// 注意，需要给vue.config.js配置changOrigin:true
// 这样才会改变来源的Host字段
devServer: {
    open: true,
        host: "0.0.0.0",
        port: 8080,
        https: false,
        hotOnly: true,
        proxy: {
        "/": {
            target: "http://localhost:3000/",
                changeOrigin: true, // 是否改变发送到后端的host字段，如果改变，那么host就是对应的target字段
        }
    }
}
```

## Access-Control-Allow-Origin
* Access-Control-Allow-Origin：`后端用来设置允许请求客户端来源origin字段的一个字段`
* 如果我们是不需要做跨域设置，那么`Access-Control-Allow-Origin:'*'`
```javascript
// node.js 运行在3000端口
res.setHeader('Access-Control-Allow-Origin','http://localhost:6334')

// 前端 运行在63343端口
ajax({url:'http://localhost:3000/',method:'get',data:'name=3&age=11'}).then((res)=>{
    console.log(res)
})
```
* 后端设置Access-Control-Allow-Origin为63343的时候，可以获取到数据
* 设置Access-Control-Allow-Origin为6334的时候获取不到！，因为不是63343
* `Access-Control-Allow-Origin字段一般被用在CORS跨域资源共享机制中`
* 如何给多个值设置Access-Control-Allow-Origin?
```javascript
    let arr=['http://localhost:63342','http://localhost:8080']
    if(arr.includes(req.headers.origin)){
        res.setHeader('Access-Control-Allow-Origin',req.headers.origin)
    }
```


### referer字段用途
* [https://juejin.cn/post/6844903954455724045]("参考")
* referer字段一般用在防盗链中，当我们在自己的网站使用别人网站的图片
* 那么别人网站会判断referer，如果我们的网站地址不在对方的白名单中，那么
* 对方会根据referer判断出我们的网址，就会拒绝发送图片资源给我们。

* referer会把前端地址栏的路径全部发送过去(除了锚点,hash这部分)，可能会包含敏感信息
* 而origin只包含协议+域名，不包含敏感信息，所以更加安全

## set-cookie
`vue项目使用的是history路由`
* set-cookie字段有以下几个值
1、key=value(字段和字段值)
2、expires(过期时间，如果不设置那么就是session,会话结束就清除cookie`内存cookie`)
* 内存cookie会随着浏览器的关闭而销毁
* `设置了expires的就是本地cookie,会以文本形式存储在操作系统本地！`
* 所以内存cookie更安全？每次打开浏览器都是新的cookie，即使被盗窃cookie,也只会有一次？
* `不是，攻击者可以通过document.cookie去更改该cookie的expires，从而变为本地cookie，延长时间`
3、path:表示路径`一般使用/表示根目录，也就是表示我们这个cokkie可以被什么目录下的资源获取到`(默认就是本页面路径)
* 然后我们看一个例子，看一下path
* `注意，set-cookie里面的值一定不要用双引号！！除了value和expires`
```javascript
// node.js
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/home')

// 然后我们前端打开/home网页
// 然后可以看到cookie的path为/home
// 然后打印document.cookie可以拿到值
// 但是在/根路径下无法获取cookie,这是因为我们设置了path,必须是home或者home的子目录才能拿到该cookie
```
* 那么路径不同，我们可以获取到别的路径下的cookie吗？可以！
```javascript
// 首先是我们写一个iframe.html
// 然后打开，在控制台直接添加一个cookie
// 然后运行index.html
// index.html代码：
let iframe = document.createElement('iframe')
iframe.src='http://localhost:63342/Myhxsj/iframe.html'
iframe.style.display = 'none'
document.body.appendChild(iframe)
iframe.onload=()=>{
    console.log( iframe.contentDocument.cookie)
}
// 最后打印出iframe页面cookie  iframe=111;
```

4、domain表示域名，`默认是当前域名`
* 看一个例子，看一下domain的应用
```javascript
// 我们在localhost启动一个后端项目
// 然后后端返回domain:app.localhost
// 注意我们得domain字段第一个值必须是.,也就是一个点
// 另外不要使用双引号，直接用.
// node.js代码:
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/;domain=.app.localhost;HttpOnly')
// 但是如果只是一级域名，那么不用加.; 例如localhost,a.com (所以也无法把根域名的cookie共享给子域!!!)

// 添加.的作用就是下一级子域(继续往下也可以拿到！)可以使用该cookie
// 不对，后来又尝试了，发现可以不加.; 但是浏览器存储的时候会自动加上. (所以子域肯定会共享父域的cookie)

// 然后我们在app.localhost网址可以访问到该cookie
// 在api.app.localhost和xxx.app.localhost都可以访问到该cookie
// 但是在localhost访问不到，也就是cookie的作用域是自己的子域，不包括父域
// 注意我们访问的其实是后端返回的网址，也就是后端端口3000，我们访问的是http://localhost:3000/
// http://app.localhost:3000/
```
* 我们可以通过给父域设置cookie,从而让子域共享父域的cookie

* 另外还有两个属性
5、`HttpOnly表示只能被http请求所读取，不能被客户端所读取（控制台打印拿不到值）`
6、`secure表示只能通过https协议发送的请求才能使用该cookie；但是secure对应的cookie可以被客户端读写`
`所以一般secure和httpOnly配合使用更安全`
```javascript
// 首先我们在node后端设置set-cookie
res.setHeader('set-cookie','a="aa";expires="Sun Jul 18 2022 10:31:45";path=/;secure')

// 然后我们在前端可以拿到对应的值
// document.cookie
// a=\"aa\"

// 然后我们新增一个b的cookie
// document.cookie = "b='abc'"

// 我们再修改以下a这个cookie(secure的cookie也是可以读写的！)
// document.cookie = 'a="111";expires="Sun Jul 18 2022 10:31:45";path=/;secure'
// "a=\"111\";expires=\"Sun Jul 18 2022 10:31:45\";path=/;secure"
// document.cookie
// "b='abc'; a=\"111\""
```
* `注意，即使key相同，如果配置项(path,secure...)不同，那么我们的cookie会存在同名的！`
* 例如存在一个httpOnly为true的a,一个为false的a;两个同时存在!

## cookie机制
* 服务端和客户端都可以进行添加，修改，删除cookie
* 服务端通过set-cookie字段可以添加，修改，删除cookie(删除就是把值设置为空或者修改expires)
* 客户端可以通过document.cookie进行添加，修改，删除cookie的操作。
* `同域内浏览器中发出的任何一个请求都会带上cookie`


