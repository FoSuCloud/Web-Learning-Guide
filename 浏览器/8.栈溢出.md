<!--
 * @Author: your name
 * @Date: 2021-03-07 16:53:11
 * @LastEditTime: 2021-03-07 22:22:15
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \myBook\浏览器\8.栈溢出.md
-->
## 为什么会有栈溢出？
### 什么情况会创建执行上下文
* 首先来明确一下，什么情况下代码才算`一段代码`，才会在执行之前就执行编译并且创建执行上下文？、
* 分为以下三种情况：
1. 当JavaScript引擎执行全局代码的时候，会编译全局代码并且创建全局执行上下文，并且在整个页面的生命周期内，全局执行上下文只有一份
2. 当调用一个函数的时候，函数体内的代码会被编译，并且创建函数执行上下文，一般情况下，函数执行完毕之后就会销毁函数执行上下文（`闭包不会`）
3. 当执行eval函数的时候，会为eval里面的内容会被编译，并且创建执行上下文

### 为什么会有栈溢出错误？
* `在JavaScript中有很多函数，经常出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构`
* 在说调用栈之前，先了解一个函数调用和栈结构

#### 函数调用
* 函数调用就是运行一个函数
* 举个例子 
```javascript
var a = 2;

        function add() {
            var b = 10;
            return a + b;
        }
        add();
```
* 这段代码就是创建了一个add函数，然后调用了该函数
* 一段代码的执行流程是：编译阶段+执行阶段
* 首先在编译阶段，创建了变量a=undefined,还有变量add指向函数，函数会被放到堆内存中
* 在执行上下文和可执行代码都准备好之后就进入执行阶段
* 执行阶段：
* 首先给变量a赋值
* 然后执行函数add,执行过程是在全局执行上下文中取出函数add的代码
* `然后对函数add的代码进行解析，把变量b放到函数执行上下文中，在函数执行上下文和可执行代码准备好之后`
* 在函数add的执行阶段执行代码b=10赋值，然后return返回结果12
* `就这样，在这段代码中会生成全局执行上下文和函数执行上下文`
* 既然由多个执行上下文，那么javaScript引擎是如何管理多个执行上下文的呢？
* javaScript引擎会使用栈进行管理

#### 什么是栈
* 栈就像是一条单行道，外面的车可以开进去，但是尽头被堵住了，想要开出去只能等最外面的车出去，才能依次出去
* 所以就是`后进先出`的数据结构。在车流量较大的时候就会反复出现入栈，栈满，出栈，空栈，再次入栈的情况

#### JavaScript的调用栈
* JavaScript引擎正是使用栈这个数据结构来管理执行上下文的，在执行上下文创建完成后，
* `JavaScript会把执行上下文压入栈中，通常这种用来管理执行上下文的栈称为调用栈`
* 看个例子:
```javascript 

var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
var d = 10
result = add(b,c)
return  a+result+d
}
addAll(3,6)
```
1. 首先创建全局执行上下文，并将其压入栈底。编译阶段：a,add,addAll三个变量都被放在全局执行上下文的变量环境中
* `在全局执行上下文创建完成后便会被放入调用栈中`,然后进入执行阶段：a被赋值为2，执行addAll函数
2. 调用addAll函数，会在全局执行上下文中找到变量addAll,找到对应的函数代码后，进入addAll函数的编译阶段
* `把d,result变量放入函数addAll的执行上下文中，把执行上下文压入栈`
* 然后进入函数addAll的执行阶段，变量d被赋值为10，然后调用函数add
3. 调用add函数，在全局执行上下文中找到变量add，找到函数add对应的函数代码
* 进入add函数的编译阶段，`把函数add的函数执行上下文压入栈中`，然后进入执行阶段，然后3+6=9，返回9
4. 函数add执行完毕后返回9，该函数的执行上下文就会被销毁，然后进入调用栈的栈顶是addAll函数
* addAll函数继续执行，result=9,然后返回2+9+10,返回21
5. 然后addAll函数的执行上下文销毁，全局执行上下文得到21。
* `调用栈其实就是JavsScript引擎追踪函数执行的一个机制`

### 开发者工具使用调用栈调试！！！
* 可以打开开发者工具的source,然后在add函数和addAll函数和全局的变量a那里打断点
* 然后可以看到在右边的call stack中，在全局变量a的时候，`只显示anonymous全局的函数入口`
* 然后断点来到addAll函数，此时的call stack显示顺序是:`addAll anonymous`,因为addAll函数被压入栈了
* 最后断点来到add函数，此时add函数也被压入栈中，所以显示顺序是`add addAll anonymous`、

`我们在addAll函数使用console.trace可以看到结果: addAll anonymous`
`另外我们在add函数使用console.trace可以看到打印调用栈为:add addAll anonymous`

#### 栈溢出
* `因为调用栈是有大小限制的，所以入栈的执行上下文达到一定数量后，JavsScript引擎就会报错`
* 例如:
```javascript 
        function add() {
            // console.log(arguments.callee) // 函数自身
                return arguments.callee()
        }
        add();
```
* 该函数因为反复调用自身，所以在调用栈的容量达到后就会报错，max call stack错误！








