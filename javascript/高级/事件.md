## 阻止冒泡/默认事件
1.如果是IE浏览器
* 阻止冒泡:window.event.cancelBuble=true;
* 阻止默认事件:window.event.returnValue=false;
2. 阻止非IE浏览器
* 阻止冒泡:event.stopPropagation()
* 阻止默认事件:event.preventDafault();
3. 但是火狐浏览器不太一样,虽然火狐也是使用W3C标准的用法，但是注意火狐使用的`event一定是要从参数中传递过来的`


## 41.支持冒泡的事件
* 支持冒泡的事件有:click,scroll,input,keyup,keydown,mousemove,mousedown,mouseover,mouseout,mouseup,select
1. mousemove :当鼠标指针在元素内移动时，mousemove事件就会被触发，任何HTML元素都可以接受此事件
2. mouseenter(不会冒泡`IE`):鼠标移入元素的时候触发
3. mouseover:鼠标穿过被选元素或者子元素的时候触发
4. mouseout:鼠标离开被选元素及其子元素的时候触发
5. mouseleave(不会冒泡`IE`):鼠标离开被选元素的时候触发
* [鼠标事件](https://blog.csdn.net/u010297791/article/details/57412796)
* [冒泡事件](https://www.cnblogs.com/rubylouvre/p/5080464.html)


## 6.js事件的三个阶段
* 1.首先事件从根节点流向目标节点，途中会经过各级DOM节点，在各个节点上触发捕获事件，还没有流到目标节点的这段时间被称为捕获阶段
* 2.当事件从根节点流到目标节点就触发目标节点的事件，这个阶段称为目标阶段
* `捕获阶段的主要任务是建立传播路经，等到了冒泡阶段就沿着这个路径流向根节点`
* 3.当事件在目标节点上被触发之后不会停止，而是会沿着捕获阶段建立的传播路径一层层流向根节点，触发节点的事件
* `注意:我们平时一般只阻止冒泡事件，因为捕获阶段默认是不触发事件的(或者说触发的是捕获的事件)，而冒泡事件是默认触发的`


## 监听事件
1. `通用的方式是 元素.onclick=function(){} 这种绑定`
2. 但是··`onclick这种方式只能绑定一个点击事件，后来加入的会覆盖掉之前的，不能同时执行`
3. 解决方法，`IE使用attachEvent,其他适用addEventListener`
```
btn.attachEvent("click",()=>{});

btn.addEventListener("click",()=>{});
```
* `attachEvent和addEventListener可以存在多个，不会被覆盖，可以同时执行`

## 事件解绑
```
			var one=document.getElementById('one');
			// 1.1 on绑定
			one.onclick=function(){
				alert('on绑定')
			}
			// 1.2 on解绑使用 onclick=null;
			var cancelone=document.getElementById('cancelone');
			cancelone.onclick=function(){
				one.onclick=null;
				alert('on解绑了再试试~')
			}
			
			// 2.1 addEventListener监听绑定
			var two=document.getElementById('two');
			var func=function(){
				alert('监听器绑定啦~')
			}
			two.addEventListener('click',func)
			// 2.2 监听器绑定使用removeEventListener解绑
			var canceltwo=document.getElementById('canceltwo');
			canceltwo.addEventListener('click',function(){
				// 2.3 需要注意:removeEventListener至少有两个参数
				// 第一个参数表示绑定的是什么事件
				// 第二个参数存在是因为addEventListener可以给一个事件绑定多次
				// 所以必须指定绑定的函数是哪个，所以预先应该用函数表达式存储函数
				two.removeEventListener('click',func);
			})
```

## 把网络图片保存到本地
1. 根据网络上的思路，创建一个a元素，然后触发点击事件
2. 该方法与我想的不太一样，但是也有值得学习的地方
```
  var a = document.createElement("a"); // 生成一个a元素
  var event = new MouseEvent("click"); // 创建一个单击事件
  a.download = name || "photo"; // 设置图片名称
  a.href = imgsrc; // 将生成的URL设置为a.href属性
  a.dispatchEvent(event); // 触发a的单击事件