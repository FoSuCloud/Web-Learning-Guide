## 小易给定你数字和系数。每次操作你可以将变成a=a+p或者将变成p=p*q。问至少几次操作使得b<=a。
* [网易校招真题](https://www.nowcoder.com/profile/4085682/test/29909774/800525#summary)
```

			var num=readline();//行数
            while(num>0){
                num--;//次数减一
                var arr=readline();
                arr=arr.split(' ');// a,b,,p,q
                var a=parseInt(arr[0]);
                var b=parseInt(arr[1]);
                var p=parseInt(arr[2]);
                var tem=p;//保存最初的p
                var q=parseInt(arr[3]);
                var p_add_num=0;//每次增加次数(以p为主)
                var a_add_num=0;//每次增加次数(以a为主)
                //每次增加可以 a=a+p(一次) // p=p*q,a=a+p (两次)
                if(a<b){
                    
                    //一般来说，划算的做法是a=a+p;毕竟只需要一次
                    while(a+p<b){
                        p_add_num++;//次数加一
                        p=p*q;
                    }
                    
                    while(a<b){
                        a_add_num++;
                        a=a+tem;
                    }
                }
                p_add_num=p_add_num+1;//还要加上一次a=a+p;
                //b<=a 的时候就满足条件
                //console.log(a_add_num,p_add_num)
               print(a_add_num>p_add_num?p_add_num:a_add_num)
            }
```

## 柱子问题[牛客网易真题](https://www.nowcoder.com/questionTerminal/f02fe9dda1c443bdbe14b5775727124f?toCommentId=5147259)
```
var num=parseInt(readline());//数据组数
			while(num>0){
			    num--;//减小组数
			    //每组有两行
			    var r_one=readline();//第一行
			    var r_two=readline();//第二行
			    var n=parseInt(r_one.split(" ")[0]);//柱子数
			    var k=parseInt(r_one.split(" ")[1]);//可跨越的柱子间隔数
			    var h_arr=r_two.split(" ");//柱子的高度数组
				h_arr.forEach((item,i)=>{
					h_arr[i]=parseInt(item)
				})
			    var end=h_arr.length-1;//目的柱子的索引
			    //console.log(h_arr)
			    // //跨越柱子的条件是1<=柱子间隔<=3,并且当前所处柱子高度>目的柱子高度
			    // //那么可以遍历柱子间隔，如果在间隔范围内有高度小于等于当前柱子的目的柱子，那么就尝试跳一下
			    var start=0;//当前所处柱子
			    var j=k;//间隔
				var max_h={height:0,index:0};//最大高度
				var flag=false;//超能力记录
				while(start<end){
			        //中转柱子小于等于的话就可以跳,中转索引是start+j
					//但是可能在柱子间隔中存在多个可以跳的选项，此时应该选择能跳的最高的柱子！
			        for(var j=1;j<=k;j++){
						if((start+j)<=end && h_arr[start+j]<=h_arr[start] && h_arr[start+j]>max_h.height){
							max_h.index=j;//获取可以跳的最高柱子的索引
							max_h.height=h_arr[start+j];
							//console.log(max_h.index)
						}
					}
					
					// 不到万不得已(此时就设置是一步都过不去的时候，那么就使用超能力)
					if(max_h.index==0){
						//第一次使用超能路
						if(!flag){
							flag=true;//改变标记
							var h_h_max=0;
							var max_i=0;
							for(var j=1;j<=k;j++){
								if((start+j)<=end && h_arr[start+j]>h_h_max){
									h_h_max=h_arr[start+j];
									max_i=j;
								}
							}
							start=start+max_i;//跳到最高峰
						}else{
							//使用过超能力还是需要再使用一次，那么就置为-1表示失败
							start=-1;
							end=-1;
						}
					}else{
						start=start+max_h.index;//跳到别的柱子上
						max_h.index=0;//恢复初始值
						max_h.height=0;
					}
				}
				//console.log(start)
			    // //跳到目的柱子上
			    if(start==end && start!=-1){
			        print("YES")
			    }else{
			        print("NO")
			    }
			}
```