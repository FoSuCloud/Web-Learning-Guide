## 函数依赖
1. `例子；在属性x确定的情况下，可以确定属性y的值，那就是函数依赖，例如班主任确定了，班级自然也就确定了`
2. `也可以是学号一样的话，那么学生名字肯定一样，所以可以说姓名依赖于学号`
3. `而学生名字一样不一定学号一样，因为可能重名，所以不可以说学号依赖于姓名`
4. 其他函数依赖的例子:`(学号，课名)=>分数，系名=>系主任`
---
5. 部分函数依赖:`存在属性X=>属性Y,而X'是Y的真子集时，属性Y部分函数依赖于属性X`
* 例如 姓名|学号|身份证，(学号，身份证)可以确定一个唯一的名字，但是学号也可以确定唯一的名字，身份证也可以确定唯一的名字
* 所以这种情况就是部分函数依赖，`注意:部分函数依赖只有属性X是组合属性时谈论才有用，单属性肯定是完全函数依赖！`
6. 完全函数依赖:`存在属性X=>属性Y，并且X'不能确定属性Y时，是完全函数依赖`
* 如: 科目|学号|分数 ，(科目，学号)=>分数，必须科目和学号组合在一起才能有唯一的分数，只有科目或者学号有多种可能
7. `传递函数依赖：属性X确定属性Y，属性Y确定属性Z，属性X不能确定属性Z`
* 如:`学号确定宿舍，宿舍确定宿舍费，学号不能直接确定宿舍费`

## 三范式
1. `一范式：只要是能在数据库中存在的数据都符合一范式`
2. `一范式:原子性，不可分割`
* 例如学生名称，学号，班级，班主任表的班主任数据明显是重复的，可以根据班级来找到班主任表
* 如果是直接这样全部都在一个表，该表的班主任列明显是冗余，但是也是不可分割，那就是一范式
3. `二范式消除了非主属性对码的部分函数依赖，有且仅有一个主属性`
* `二范式要求表里的所有非主属性都对码有完全函数依赖！`
4. `三范式消除了非主属性对码的传递函数依赖，也就是说三范式中的非主属性不能对其他非主属性存在函数依赖`
5. [参考](https://www.cnblogs.com/rosesmall/p/9585655.html)

## 数据库事务
1. 数据库事务是构成单一逻辑工作单元的操作集合
2. 一个经典的数据库事务如下:
```
BEGIN TRANSACTION  // 事务开始
SQL1
SQL2
COMMIT/ROLLBACK 	//事务提交或者回滚
```
3. `数据库事务可以包含一个或者多个数据库操作，但是这些操作构成一个逻辑上的整体`
4. `构成逻辑整体的这些数据库操作，要么全部执行成功，要么全部不执行`
5. `构成事务的所有操作，要么全部对数据库产生影响，要么全部不产生影响，即不管事务是否执行成功，数据库总能保持一致性`
6. `以上在数据库出现故障以及并发事务的情况下依旧成立`

## 事务解决问题的实例
```
BEGIN TRANSACTION
A账户减少100元
B账户增加100元
COMMIT
```
* `当数据库崩溃时，系统能够以事务为边界进行恢复，不会出现A账户减少，而B账户未增加的情况`
* `当有多个账户同时操作数据库，数据库能够以事务进行并发控制，使多个账户对B账户的转账操作互相隔离`

## 事务的ACID特性
1. 原子性Atomicity,事务中的所有操作作为一个整体像院子一样不可分割，要么全部成功，要么全部失败
2. 一致性Consistency,事物的执行必定使数据库从一个一致性状态到另一个一致性状态
3. 隔离性Isolation,并发执行的事务不会互相影响，其对数据库的影响会跟他们串行执行时的结果一样。
4. 持久性Duration,事物一旦提交，其对数据库的更新就是持久的，任何事务或者故障都不会丢失该数据

* 个事务只能包含对一个数据库实例的数据操作，不允许跨多个数据库实例，跨多个数据库实例需要分布式事务支持
* 数据库事务会给数据库带来并发操作带来一定影响，会降低系统的并发能力
## [参考](https://www.cnblogs.com/takumicx/p/9998844.html)

## where和having的区别
* “Where”是一个约束声明，在`查询数据库的结果返回之前`对数据库中的查询条件进行约束，即在结果返回之前起作用，且where后面不能使用“聚合函数”；
* “Having”是一个过滤声明，所谓过滤是`在查询数据库的结果返回之后进行过滤`，即在结果返回之后起作用，并且having后面可以使用“聚合函数”。
* `Having用来限制分组统计结果信息的显示`

## 删除数据库中的表
1. `drop table把表的数据和结构等等删的干干净净`
2. `delete table把表的内容删除，不删除表的结构(定义还在)，而且可以加where条件`
3. `truncate table也是删除表的内容，不删除表的结构(定义)，但是不能加where`

## 数据库文件中主数据文件扩展名是.mdf(primary data file)和次数据库文件扩展名是.ndf(secondary data file)

## 在Oracle数据库的逻辑结构中,从大到小的顺序是 表空间——段——区——块

## select count语句
```
select count(*) from table 表示返回表中包括空行和重复行在内的行数,但是会扫描所有列
select count(1) from table 也是返回表中包括空行和重复行在内的行数，不会扫描所有列,1其实就是表示有多少个符合条件的行，但是此时没有where,所有没条件也就是返回总行数
select count(id) from table 表示返回表中存在该列id的行数，但是该列的值不为空，为空的不计算，所以在此题中是不能用这个，因为tg_email都为空，用主键可以，因为主键肯定不为空
select count(distinct id) from table 表示返回数据表中id该列id不一致的个数
```

## sql的模糊查询匹配模式
1. `% 表示0个或者多个字符`
2. `_表示任意单个字符！`
3. `[]匹配中括号内的某一个字符`
4. `[^]匹配不在中括号内的某一个字符`
* 例子:`WHERE LIKE '_YOU%' 可以匹配到 IYOUHAHA `
* `WHERE LIKE '[ABC]YOU[^ABC]' 匹配到 AYOUE`

## desc table_name打印某个表结构 