## 浏览器内核
* `其实浏览器内核分为渲染引擎和js引擎，但是后来由于js引擎越来越独立，所以浏览器内核就单独指代渲染引擎了`
1. webkit内核:`safari(苹果开发的浏览器)、chrome(在啊chromium项目中研发出了blink内核，也是基于webkit内核，之后的chrome浏览器都基于blink内核，大多国产浏览器也是基于blink内核)`
2. trident内核:`IE,360,搜狗`，国内很多所谓双核浏览器的兼容模式就是使用trident内核的
3. gecko内核:`firefox`，特点是gecko代码完全公开
---
* `iphone,ipad等苹果的移动端产品使用的是webkit内核`
* `android4.4之前使用的也是webkit内核，之后使用chromium内核，chrominum内核是webkit的内核blink的分支`

## localStorage/sessionStorage
1. localStorage和sessionStorage都是用来存储客户端临时信息的
2. localStorage和sessionStorage都是只能存储字符串类型的对象
3. localStorage的生命周期是永久的，这意味着除非主动去秦楚这些localStorage信息，否则这些信息会永远存在
4. sessionStorage的生命周期是当前窗口或者标签页，一旦窗口或者标签页被关闭了，那么sessionStorage存储的数据也就被清空了
5. `资源共享`
```
1. 相同浏览器的不同页面(同源页面)可以共享localStorage数据
2. 不同页面或者标签页之间没办法共享sessionStorage的信息
注意:不同页面和标签页指的是顶级窗口，如果一个标签页包含多个iframe标签而且都属于同源页面，那么可以进行sessionStorage共享
```

## 36.响应式网页设计
* 响应式网页设计就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。

## 38.utf8/gbk
* gbk编码是国内使用较多的编码，但是`只能用于简体中文`
* utf-8编码是国际上用的多的编码，可以识别简体中文，繁体中文，日文，韩文，英文，阿拉丁文等语言

## 1.浏览器页面由哪三层构成，分别是什么，作用是什么？
浏览器页面由结构层，表示层，行为层构成；分别是HTML,CSS,JavaScript；HTML的作用是实现页面结构，CSS的作用是实现页面的表现和风格，JavaScript的作用是进行客户端的功能，进行DOM操作
## 2.DOM的理解
DOM是文档对象模型(Document Object Model)的简称，是W3C国际标准组织推荐的可拓展标志语言(XML)的标准编程接口.在网页上，文档的对象被组织成树形结构，用来表示文档中的对象模型的就是DOM.
## 3.XML
XML（Extensible Markup Language）可拓展标记语言是W3C的推荐标准，虽然很像HTML语言，但是XML和HTML有以下不同。
* XML是用于数据的传输和存储的；HTML是用于显示数据的
* XML标签没有被预定义，需要自己定义；而HTML中使用的标签都是已经预定义过的
## 4.DOM解析XML的优缺点
1. 优点：
* 使用DOM的话，网页的文档会被组织成树形结构，利于理解，方便开发
* 在解析XML的过程中，树结构被存储在内存中，可以随时修改
2. 缺点：
* 由于是一次性读取文档，所以对内存的消耗有点大，所以才存在懒加载这种方式
* 由于XML文件过大，可能影响解析性能，可能出现内存溢出(注意：这里不是内存泄漏)
## 5.内存溢出，内存泄漏
1. 内存溢出是自己要求n大小的内存，但是超过了系统所能分配的内存，系统不能满足自身的需求，因此产生了溢出
2. 内存泄漏是JS中比较常见的错误，也算是没办法避免的，就是系统给变量分配了内存，但是变量已经没有被引用了，可是变量依旧不会被释放内存，有一点点内存泄漏是没问题的，但是多了的话，可分配的内存就会越来越少就会出现问题。
## 6.浏览器的重绘重排
  在浏览器下载完所有组件，html,css,js和图片之后，会解析生成两棵树，第一棵树是DOM树，第二棵树是渲染树
* 在文档初次加载的时候，浏览器引擎通过解析html文档构建一颗DOM树，之后按照DOM元素的几何属性构建一颗用于渲染的渲染树，渲染树中的节点也被称为盒子;可以理解为一个页面元素是一个具有内容，内填充，边框，外边距和位置的盒子
* 注意：由于在浏览器中设置了隐藏的元素不会显示(display:none不会占据位置,visibility:none虽然也隐藏但是会占据DOM位置,相当于透明度为0)，所以渲染树中并不会包含渲染元素(所以改变了隐藏样式为显示之后会有重排/重绘)
* 注意：对于使用流式布局的浏览器来说，对渲染树的计算只需要遍历一次就可以完成;但是table及其内部元素除外，需要多次计算才能确定其在渲染树中的属性，所以一般不用table布局
---
1. 重绘(`repaint`)：
  相当于元素的外观变化所触发的浏览器行为，例如改变color,background-clor,outline, 浏览器会根据元素的新属性进行重新绘制，让元素呈现新的外观，
     记住：重绘不会带来新的布局，只是改变布局内的元素外观
2. 重排(`reflow:所以也叫回流`)：
  当DOM事件导致元素的宽高位置改变的时候，浏览器需要重新计算该元素的几何属性和其他元素的几何属性，并且位置也可能会随之改变，例如float:left变为float:right。当发生重排，浏览器会使渲染树中受影响的部分暂时失效，然后重新构造渲染树
 ` 注意：重排一定伴随着重绘，重绘不一定会导致重排`
 
3. 触发重排的操作:
  * 改变元素的大小，位置，内容(内容一般只伴随着重绘，但是例如往p元素中填充一大堆文字，然后超过了父元素本来的大小，那么父元素的大小就会被撑开，导致重排)
  * 元素节点的增删，移动操作也会导致重排例如往第一个li元素前面添加一个li元素，那么后面所有的li元素以及之后的渲染树部分都要重排,但是往最后一个li元素后面添加一个li元素，就没有li元素需要重排，之后最后一个li元素之后的渲染树需要重排
  
## 7.浏览器存储
* `IndexdDB 是 HTML5 的本地存储,容量无限大，除非清除否则一直存在`，把一些数据存储到浏览器（客户端）中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用。
* Cookie 通过在客户端 ( 浏览器 ) 记录信息确定用户身份，单个cookie最大为 4 kb ，在浏览器请求中每次都会附加在请求头中发送给服务器(`注意，cookie不设置过期时间的话，那么默认退出浏览器之后cookie就过期了`)
* SessionStorage 仅当前页面有效一旦关闭就会被释放。也不会随浏览器发送给服务器。大小5M或更大
* localStorage 也是 HTML5 的本地存储，将数据保存在客户端中（一般是永久的）。

## 8.cookie与session
* cookie是客户端使用的记录客户信息状态的机制
* Session是服务器端使用的一种记录客户端状态的机制(与浏览器的sessionStorage存储区分开来)

## 9.防抖节流
* 防抖和节流其实都是防止函数多次调用，`防抖是在除了第一次点击，之后的点击想要生效，必须由一定的间隔时间，也就是快速点无数下，结果也只有一下被响应`
* `而节流则是在一定的时间间隔内,点击一次或者多次都只识别一次，但是和防抖不同的是，假设间隔为1秒，则在3秒内一直连续点击，防抖只会响应一次，而节流会响应三次，因为每一秒都会响应一次`

## 10.页面的性能指标详解：
* 先触发白屏时间(first paint time)再触发可交互时间(dom ready)
1. 白屏时间(first paint time)用户从一开始打开页面到页面`开始有东西出现`，一般认为浏览器解析完"head"标签或者开始解析body标签就是白屏时间结束
2. 首屏时间是`用户看到的第一屏`，也即是网页顶部大小为当前窗口的区域显示完整的时间。首屏时间是衡量用户体验的一个重要因素，一般首屏时间应该在5秒以内
3. 用户可操作时间(user interactive)指的是用户可以进行正常的点击，滚动事件的时间，默认可以统计可交互时间(dom ready)
4. 总下载时间:页面所有资源都加载完并呈现出来的的时间,也就是onload时间

[参考链接](https://blog.csdn.net/qq_41047322/article/details/82814396)

## 11.script标签位置
1. head部分的脚本:把脚本放在head部分，可以保证脚本在任何调用之前就被加载了
2. body部分的脚本:当页面被加载的时候，脚本就被放在script标签所在的位置，放在body部分的脚本通常被用来生成页面内容
3. 如果把js放在head标签中先解析，那么此时body标签还没有被解析
4. 从性能的角度看，把脚本放在head标签中，脚本会阻塞其他资源的下载和页面渲染，这样用户就没办法快点看到页面，白屏时间就很长，所以我们应该把标签放在body标签底部，以尽量减少页面下载的影响

## 12.AMD(asynchronous modules definition)规范诞生
* `为什么会诞生模块呢?`2009年出现了node.js，将js用于服务器端编程，在以前的话，js都是用于浏览器端编程，对于浏览器端编程，没有模块也没有问题，因为浏览器端的程序一般都不是很复杂。
* 但是node.js让js开辟了服务器端领域，js想在服务器端编程就必须要有模块，与操作系统和其他应用程序交互，否则很难编程
* 看一个例子
```
var math=require('math')
math.add(2,3);//5
```
* 对于服务器端来说，所有的模块都存在本地硬盘中，可以同步加载完成，模块加载时间其实就是读取时间；但是对于浏览器端来说，模块都存放在服务端，所以模块加载时间就取决于网速了，可能要等很久，所以浏览器就相当于存于"假死状态"
`所以浏览器端的模块不能和服务器端的模块一样使用commonjs规范，因为commonjs规范是同步加载，而浏览器端的等待时间取决于网速，所以不能使用同步加载一直等待加载完毕，应该使用异步加载，这也是AMD规范诞生的背景`

## 13.AMD(asynchronous modles definition)规范
* AMD规范是Require.js在推广过程中对模块化定义的规范化产出，就是一个概念。
* Require.js是一个AMD框架，可以`异步加载`js文件，通过define()函数定义，第一个参数是数组['依赖的包']，第二个参数是回调函数，最后通过return来输出
* `关键词:依赖前置，Require.js,提前执行`

## 14.CMD(common modules definition)规范
* CMD是SEA.js在推广过程中对模块定义的规范化产出
* CMD是一个同步模块，而SEA.js是淘宝团队提供的模块化开发的js框架
* 也是通过define()定义，通过require加载jq插件，CMD是依赖就近，在哪里使用插件就在哪里require,即用即返，这也是同步的概念
* `关键词:依赖就近，延迟执行，Sea.js`

## 15.commonjs规范
* commonjs规范是通过module.exports定义的，`在前端浏览器中不支持`！
* module.exports是通过node.js服务器端使用的，`node.js使用的是common.js规范`;`而前端浏览器一般使用AMD,CMD,ES6等规范开发的`
* `关键词:同步加载，服务器端的，node.js环境，拷贝`

## 16.ES6规范import/export
* ES6规范是通过import/export对模块进行导入的
[参考](https://www.cnblogs.com/littlebirdlbw/p/5670633.html)
['参考'](https://blog.csdn.net/tangxiujiang/article/details/81104174)

## Commonjs导出的值是拷贝(因为是服务器端的，所以肯定是拷贝)
## es6导出的值是引用(为了某个部分的修改能够影响到整体)
* [参考](https://www.cnblogs.com/liangcheng11/p/8417557.html)
## ES6模块
1. export用于暴露模块对象给别的模块使用
```
1. export {one,two}通过 export {变量名}的方式暴露变量给别的模块使用
```
2. import用于在一个模块中使用另一个模块的接口
```
1.import {one,two} from a.js 通过 import {变量名} from 模块文件名.js的方式引用别的模块的变量

```

## document.ready和window.onload的区别
* document.ready表示文档结构已经加载完成，也就是除了图片外部文件等之外都加载完成了
* window.onload表示包含文件等外部文件都已经加载完成`也就是window.onload在document.ready之后`


## 17.web性能优化
1. 减少http请求数
2. 压缩外部文件，减少体积
3. 把script文件放到body标签底部(放在head标签中会导致页面先加载该文件再继续解析Body标签的内容，导致页面白屏时间长)，以免影响页面加载速度，用户体验不好
4. 合并图片从而减少请求数
5. css外部文件必须放在head标签中，否则放在body标签中，可能还没有下载完或者解析css文件，浏览器就根据body标签内容开始渲染页面构建DOM树了，但是样式还没有解析完成就会导致用户体验极差
6. 重绘跟重排应该尽量减少，特别是重排会让浏览器重新计算各个元素的位置，大小更加消耗资源，而重绘仅仅影响到自己那个元素
7. 减少不必要的DOM操作

## 18.web安全
* 客户端脚本安全
1. 跨站脚本攻击(XSS)
* XSS攻击指的是黑客通过"html注入"的方式篡改了网页，插入了恶意的脚本，从而在用户浏览网页的时候，控制用户浏览器的手段
* 最常见的XSS攻击是通过读取浏览器cookie对象，从而发起"cookie挟持"，当前用户的登录凭证保存在浏览器的session，客户端浏览器的cookie中,而浏览器的cookie被挟持之后，意味着黑客可以不通过密码直接登录系统
* 防御:`在cookie劫持这种XSS攻击中，可以用在cookie字段中加入httponly 来防止js获取cookie`
* 或者对`<>[]这种特殊的字符进行输入检查` 
2. CSRF(cross site request forgery跨站请求伪造)攻击及防御
*  首先用户访问网站a,输入账号和密码，服务器校验后返回set-cookie字段给用户浏览器
*  用户把数据存储在cookie字段中，然后用户在同一浏览器中访问网站b
*  `此时用户a还没有退出网站a`，然后网站b被用户访问之后，除了返回正常的代码，还返回了`攻击性的代码`
*  浏览器在接收到网站b发送的攻击性代码后，按照代码里面的请求去对网站a发起请求，此时的浏览器还带有cookie信息，然后网站b的攻击性代码就带着cookie向网站a发起了请求，而网站a看到cookie就不会怀疑，所以网站b可以获取到用户该有的权限，可以窃取资料或者进行转账等要求
*  防御:1.验证referer字段(该字段是记录发起请求的前一个页面地址的，而origin是最初的页面地址)；2.使用token验证，黑客可以获取到cookie，但是我们可以在http参数中加入token，然后在服务器中加入一个拦截器来验证；

* 服务器端应用安全
* 服务器端的安全比起客户端更加重要，因为服务器端的某个安全漏洞导致的是所有使用它的客户端都有安全漏洞
1. SQL注入攻击
* SQL注入攻击有两个关键条件:1. 用户能够控制输入 2. 原本程序要执行的代码，拼接了用户的输入的数据
* 防御手段
1.1 使用预编译语句，这是防止SQL注入最有效的方法，可以完全避免程序代码拼接带来的风险(这也是我们不使用eval()的原因)
1.2 关闭web服务器的错误回显功能，避免`便利了黑客改正错误的方便性`


## 数据传输过程
* 互联网中的数据是通过数据包来传输，如果发送的数据很大，那么就会被拆分为多个数据包，那么数据包送达到应用程序需要解决三个问题:
1. 如何送达到目的主机
2. 主机如何把数据包送到应用程序
3. 数据包如何被`完整`的送达到应用程序
---
1. `IP(Internet Protocol)协议:把数据包送达到主机`
* 如果想把数据包从主机A发送到主机B，那么在数据包被传输之前，数据包之上会被附加上主机B的IP地址信息，同时为了让主机B能够回复信息给主机A，该数据包还需要附加上主机A的IP地址信息
2. `UDP(User Datagram Protocol)用户数据包协议把数据包发送给应用程序`、
* IP协议把数据包发送给主机B之后，主机B并不知道该把这个数据包发给音乐还是王者，所以这时候就需要UDP协议了。
* 端口号会被装进UDP头里面，UDP头再和原始数据合并组成新的UDP数据包，注意`UDP头里面除了目的端口号，还有源端口号(来源)`，UDP协议就会把数据包发送到目的端口所在的应用程序，应用程序回复信息的时候就往源端口号中发送数据包
---
* `注意，在主机A中制作数据包，首先在传输层加上UDP头(端口号)，再到网络层加上IP头(ip地址)；而到了主机B中，首先在网络层卸下IP头，再到传输层卸下UDP头`
---
* UDP协议存在两个问题
1. 数据包在传输过程中容易丢失(不会重发)
2. 大文件被拆分为多个数据包，这些数据包在不同的时间被发送出去，而`UDP协议不知道该如何组装这些数据包为完整的文件`。
---
* 为了解决这两个问题，我们使用了TCP(Transmission Control Protocol)数据传输控制协议
* TCP传输控制协议是一种面向连接的，可靠的，基于字节流的传输层通信协议
* TCP协议有以下两个特点
1. `发生数据包丢失的时候，TCP提供数据包重传机制`
2. `TCP协议引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件`
---
* 和UDP协议一样，TCP协议也需要端口号，但是除了端口号还需要一个排序号
* `TCP和IP协议配合的流程，首先在主机A中的传输层给数据包加上TCP头(端口号，排序号)，然后再在网络层给数据包加上IP头(IP地址)；等到了主机B的网络层就先拆解IP头，再到了传输层拆分TCP头`
---
* TCP建立连接使用三次握手
* TCP释放连接使用四次握手
1. 客户端首先发送一个FIN给服务器端，然后关闭自己到服务器端的连接,
2. 服务器端接收到客户端发送过来的FIN，然后发送一个ACK给客户端，告诉客户端自己收到了信息
3. 服务器端发送了ACK之后，再向客户端发送一个FIN,然后关闭服务器端到客户端的连接
4. 客户端接收到服务器端发送过来的FIN后，发回一个ACK报文确认，然后等待服务器关闭，服务器接收到客户端发来的ACK后关闭，然后客户端也关闭连接

## 大小写敏感
1. html,css对大小写不敏感，但是推荐用小写
2. js对大小写敏感，例如 a变量和A变量是不一样的，但是在html,css中是一个样的

## js脚本的加载方式
`没有defer,async属性时`
1. 浏览器一边下载html网页，一边解析
2. 在解析代码过程中发现script标签
3. `停止解析，把网页渲染控制权交给js引擎(js可以修改DOM,所以解析到js代码必须把网页渲染控制权交给js引擎，否则会导致线程竞赛问题)`
4. 如果js标签引入了外部脚本就并行下载外部脚本(`此时继续执行下面的代码，但是下载完毕之后就把控制权交给浏览器`)，否则就直接执行js脚本代码
5. 在script标签执行完毕之后，`把浏览器网页渲染控制权还给浏览器`，继续执行往下的html代码
---
* 对于多个script标签,如果这些标签都是下载外部文件，如
```
<script src="a.js"></script>
<script src="b.js"></script>
```
* `这几个文件会被并行下载,但是下载完成之后，执行顺序一定是a再到b。注意:下载这两个外部文件会造成阻塞，必须下载完成，浏览器才会继续进行页面渲染`
---
* 有defer属性的script标签
1. 浏览器一边下载html代码，一边解析
2. 解析到有defer属性的script标签的时候
3. `浏览器会继续往下解析html代码，同时并行下载defer属性的script标签的外部文件`
4. `在浏览器DOMContentLoaded事件触发之前(/html标签被读取之前)执行下载的外部defer属性脚本`
---
* 有async属性的script标签
1. 在解析的时候发现有async属性的script标签就并行下载script外部文件
2. `在下载async外部文件的时候继续解析网页；在下载完外部脚本之后，立马！执行外部脚本`
3. `在外部脚本执行完之后，继续解析下面的网页`

## 资源阻塞
1. 虽然按照传统浏览器来说，`img标签放在script标签之后`，应该要等到script代码下载并执行完成之后才会下载，但是`现代浏览器都是并行下载，但是还是会阻塞渲染`
2. `img标签放在script标签之前的时候，两者是并行下载`
3. `在css外部资源后面跟着script外部文件的时候,css就会阻塞js的下载`，因为css是样式啊，需要先渲染，这是浏览器的规则，`css样式必须在嵌入的js代码之前下载解析渲染完成`
4. `如果css外部资源在script外部文件后面，那么就是并行下载`，会先执行js代码
5. `iframe,img这些外部资源是异步加载，所以遇到普通的script标签，会先执行script标签内容(控制权在这里)，即使下载完了也不会中断script的解析`
* [参考](https://www.cnblogs.com/hgonlywj/p/4857151.html)
* [重要!!!](https://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html)

## web页面生命周期
* 根据链接的例子:[例子](http://www.html-js.com/article/4585)
1. 浏览器的一般加载顺序为(同步的script):
```
script executed;readyState:interative;DOMContentLoaded;image onload;iframe onload ;readyState:complete ;window:onload
```
2. 可以看出来:`同步的script总是先于其他事件执行，而window.onload事件总是最后执行，image/iframe的执行顺序总是在中间，具体是不固定的`
---
3. 需要记住:`同步的script总是先执行的，比DOMContentLoaded先执行`
4. 在DOM准备就绪之后(`也就是页面文档完全载入并且解析完成之后，仅仅是页面文档,不包括外部资源`)，DOMContentLoaded事件在document上触发，`我们在DOMContentLoaded阶段使用js操作DOM节点,这也意味着程序执行从同步脚本阶段转移到事件驱动阶段`
5. 在js脚本执行完毕之后，可能还有异步外部资源(iframe,img)在载入过程中
6. 网页所有资源都`载入完毕，才开始执行document.onload事件`
---
* 如果再细分，我们可以使用document.readyState来表示文档的当前状态
1. loading:文档正在载入
2. interactive:在DOMContentLoaded`之前`触发，相差时间很短
3. complete:在document.onload`之前`触发，相差时间很短，此时也已经完全加载所有资源
---
1. 在onload页面加载完成之后还有其他生命周期
2. onpageshow事件在用户浏览网页的时候触发，跟onload事件很相似，但是onpageshow事件会触发多次，即使页面是从缓存中读取的也会触发，而Onload事件只在页面初次加载的时候触发，而Onpageshow事件的话，即使页面回退返回该页面也会触发，而Onload不会触发
3. beforeunload事件一般在页面卸载之前触发，常用于在关闭浏览器的时候弹出一个对话框，向用户询问是否确定关闭

## document.write()重写网页文档流
1. `window.onload=function(){	document.write('i am')	}`这样一段代码，无论之前网页内容是什么，此时在文档内容完全加载之后(文档已经关闭)再去执行docment.write()函数会自动调用window.open()函数创建一个新的文档流，写入新的内容，再通过浏览器显示，这样会覆盖原来的内容
2. 如果使用document.write()的时候，文档流并没有关闭，`那么即使调用document.write()方法也不会使用open()方法，因为文档流并没有关闭，所以也就不会覆盖了`
3. `document.close()	document.write('i am')这样也不会覆盖文档流`，因为document.close()只能关闭自己使用ocument.write()打开的文档流，不能关闭浏览器自己打开的文档流
4. 所以我们不能在异步文件中使用documen.write()函数，防止异步加载的时候，文档流已经关闭了，这样就会出现文档流覆盖的问题


## 浏览器手写动画最小时间间隔
* 建议最小时间间隔为0.1-0.3s
`多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms`

## 增量模型
* 把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件

## 网卡
* 网卡工作在数据链路层，但也可以向下兼容物理层。实现数据的`封装与解封`，链路管理，编码与译码功能。

## Chrome浏览器支持#9497 这种四位的颜色表示，最后一位是透明度！

## 浏览器页面之间通信
1. 服务器方式就是通过提交表单更新服务器端的数据，然后另一个页面去获取更新后的数据就可以实现通信
2. 第一个页面通过localStorge.setItem()来实现存储在浏览器本地，另一个页面通过localStorge.getItem()来获取被存储的数据
3. 第一个页面把要存储的信息存储到cookie中，然后另一个页面通过setInterval来实现定时获取

## Cookie
1. `cookie一般是在服务器端生成，存放在浏览器端的，不过浏览器端也可以通过js代码设置cookie`
2. `cookie可以在跨域请求中被请求头携带`
3. `如果生成cookie的时候不设置expires,那么该cookie默认在浏览器会话结束后就消失`

## 浏览器页面之间的通信方式
1. 设置本地localStorage,通过setItem()存储，getItem()获取
2. `cookie配合Interval来实现定时获取cookie`
3. `sessionStorage不能实现浏览器之间的通信！！！因为sessionStorage是会话级别的，每个页面都是单独的sessionStorage`

## script中使用import
```
	<script type="module">
		import Browser from './js/browser.js'
		// 设置script type="module" 才能导入模块 import from 
		console.log(Browser.client.name+" "+Browser.client.version);
	</script>
```

## cookie的读写
```
			var date=new Date();
			// 存储cookie,参数为 键=值;expirationdate=过期时间(Date格式);path=可以访问的域名
			document.cookie="name=yiye;expirationdate="+date+";path=/";
			document.cookie="age=11;expirationdate="+date+";path=/";
			document.cookie="sex=男;expirationdate="+date+";path=/";
			var cookie=document.cookie;
			console.log(cookie);//name=yiye;age=11; sex=男
			var age=cookie.split('age')[1].split('=')[1].split(';')[0];
			console.log(age);//11,取得cookie的值
```

## 如果cookie没有添加expires,那么默认在退出页面后cookie被消灭

## 32.javascript中实现跨域的方式总结
1. 第一种方式：jsonp请求；jsonp的原理是利用`<script>`标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有`<img>`
2. 第二种方式：`document.domain`这种方式用在`主域名相同子域名不同`的跨域访问中
* 主域名:`有两个或以上的字母组成，中间有点号隔开，但是只有一个1点号，如 badu,net`;子域名:`主域名之下的子域名，会有多个点号 blog.badu.net`
3. 第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
4. 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
5. 第五种方式：CORS(cross origin resource sharing)跨域资源共享；CORS背后的基本思想，就是使用`自定义的HTTP头部`让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
* [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)
6. 第六种方式：Web Sockets；web sockets原理：在JS创建了`web socket`之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为`web sockt协议`。
