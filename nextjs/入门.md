## next
* node要求最低12.22.0
* react最低要求17.0.2

## 编译
* Next.js 现在使用基于 Rust 的编译器`SWC`来编译 JavaScript/TypeScript。
* 这个新的编译器在编译单个文件时比 Babel 快 17 倍，并允许快 5 倍的快速刷新。
* `编译是为了将代码转换为浏览器可以识别的代码`


## build
* `构建的目的是为了减少代码文件数量，也就减少了用户访问网页时对文件的请求数量`
* `构建是解决网络依赖关系并且将文件（或者模块）合并（或打包）为浏览器优化捆绑包的过程`

## 代码拆分
* 我们的多页面项目，可以从不同的URL中访问到这些页面。`这些页面中的每一个都可以成为应用程序的唯一入口点`
* `代码拆分是将应用程序的包拆分为每个入口点所需的较小的块的过程。目标是通过仅仅加载运行该页面所需的代码来缩短应用程序的初始加载时间`
---
* `next内置了对代码拆分的支持`
* `页面之间共享的任何代码都会被拆分到另外一个包中，避免在进一步导航时重新下载相同的代码`

## 动态导入
* `使用动态导入，可以让对应组件不包含在页面的初始js包中。例如我们的tab页面就可以把tab内容的组件使用动态导入，点击了tab再加载这个js`

## 构建时间
* 构建时间是为了生产应用程序代码准备的一系列步骤的名称
* 当构建应用程序时，next.js会将代码转换为生产优化文件，以准备部署到服务器并供用户使用。这些文件包括：
1）静态生成页面的html文件
2）用于在服务器上呈现页面的js文件
3）使得页面在客户端交互的js文件
4）css文件

## 运行时间
* `运行时间也叫做请求时间，是指在应用程序构建和部署之后，应用程序响应用户请求而运行的时间段`

## 渲染
* `注意，next可以在页面级别选择渲染方式。例如页面 a渲染使用静态网站生成的方式在build的时候渲染，页面b渲染服务器端渲染`
1. 客户端渲染
* 在标准的react程序中，浏览器从服务器接收一个空的html文件以及构建ui的js代码
* 由客户端实现渲染，这就叫做客户端渲染。因为初始渲染工作发生在客户设备上，

2. 预渲染
* `相比之下，next.js默认是预渲染每个页面，预渲染也就意味着html是在服务器上生成的，而不是由客户端的js生成的！`
* 所以，在等待服务器发送渲染好的页面html之前，用户将看到一个空白页面。
---
* 预渲染分为以下两种
1）服务器端渲染
* `使用服务器端渲染，页面的html是在服务器上为每个请求生成的，然后将生成的html,json数据和使得页面具有交互性的js指令发送到客户端`
* `在客户端，html用于显示快速的非交互式页面，而react使用json数据和js指令使得组件交互性（例如按钮点击事件）。这个过程被称为水合作用`
* 在next.js,使用getServerSideProps渲染服务器渲染页面
2）静态网站生成
* `静态网站生成方式，html也是在服务器生成的。但是和服务器端渲染的区别在于`
* `静态网站生成方式，在部署应用程序的时候，一次性生成内容，直接存储html,js,css文件，一次生成，多次使用`
* 后面不管用户打开程序多少次，每次都是后端直接响应相同的文件回去就好了
* `在next.js,可以使用getStaticProps生成静态页面`
---
* 您可以在构建站点后使用增量静态重新生成来创建或更新静态页面 。这意味着如果您的数据发生变化，您不必重建整个站点。

## 创建新页面
* 直接在pages页面下新建目录，新建文件，其实就是和路由对应起来了
* 例如在pages下面新建posts目录，posts目录下面新建a.js文件
* `也就是新增了/posts/a 路由，可以直接访问该页面了！`

## Link标签
* 在 Next.js 的`生产版本`中，`只要Link组件出现在浏览器的视口中，Next.js 就会自动在后台预取链接页面的代码。`
* 当您点击链接时，目标页面的代码已经在后台加载，页面转换几乎是即时的！

## css
* next.js 内置支持css modules, sass,styled-components

#### 添加全局 CSS
* `需要在pages下面添加一个_app.js,实现导入全局css`
* `在_app.js中import xx.css`



