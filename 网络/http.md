## http各个版本
1. http/0.9
* http协议是基于tcp/ip协议的应用层协议，不涉及数据包的传输，主要用于规定客户端和服务器端的通信格式，默认使用80端口
* 最早的版本就是91年发布的0.9版本，只有一个命令get:`get /index.html`
* 而且该版本只能回应html格式的字符串
2. http/1.0
* 96年发布了1.0版本，除了get命令还引入post,head命令；
* 另外Http请求的格式也变了，除了数据部分，每次请求都必须有`头信息`
* 还新增了`状态码，缓存，权限`
* 由于每次的tcp连接只能发送一个请求，然后就关闭，所以在1.0版本引入了`Connection:keep-alive来要求服务器不要关闭tcp连接`
3. http/1.1
* 发布时间只比1.0版本晚了半年，最大的变化就是引入了`持久连接,也即是tcp连接默认不关闭，不用声明Connection:keep-alive,当服务器或者客户端发现对方一段时间没有请求就主动关闭连接，但是规范是客户端在最后一个请求发送Connection:close明确要求服务器关闭连接`
* 并且，`对于同一个域名，多数浏览器可以持久化6个连接`
* 新增了`PUT,OPTIONS,DELETE方法，还新增了Host字段`
4. http/2(很小浏览器和服务器支持，所以才会有websocket)
* 支持在未经客户端许可的情况下，`主动向客户端推送内容`
* http/2的`头信息和数据体都是二进制 头部压缩`，而http/1.x的头信息是文本(ASCLL编码)，数据体可以是文本也可以是二进制
* 支持多路复用，因为有流id,所以可以`通过一个http请求实现多个http请求传输`变成了可能
[参考](https://blog.csdn.net/zq_king/article/details/80319847)

## 传输协议
1. 单工协议（例如http1.0及以下都是）
   * 在任何时刻都只能单向传输数据，就是a只能是发送器，b只能是接收器
    * 例如只能从a到b(a->b);而不能由b发送给a!
2. 单双工协议（如：http1.1）
   * 在任何时刻都只能向一个方向传输数据，但是也可以向反方向传输数据，而且可以交替进行
    * 就是a是发送器也是接收器，b是发送器也是接收器
3. 全双工协议(如：http2.0)
* 在任何时刻都可以双向传输数据！也就是可以同时存在a向b发送数据，b向a发送数据！

## HTTP协议
* HTTP协议是建立在TCP连接基础之上的。HTTP协议是一种允许浏览器向服务器获取资源的协议，是web的基础.HTTP协议也是浏览器使用最广的协议
`浏览器端发起HTTP请求流程`
1. 构建请求
* 首先浏览器构建`请求行`信息，然后准备发起网络请求。请求行如:`GET /index.html HTTP1.1`
2. 查找缓存
* 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中`浏览器缓存是一种在本地保存的资源副本`，可以供下次请求直接使用。
* 当浏览器发送请求行中请求的资源已经在浏览器缓存中有副本了，那么浏览器会拦截请求，返回资源副本，并且直接结束请求，好处有:
+ 缓解服务器端的压力，提升性能
+ 对于网站来说，缓存是实现快速资源加载的重要一步（有时直接用缓存就可以了不需要发起网络请求）
3. 准备IP地址和端口
* `HTTP是应用层协议，用来封装文本信息然后发给传输层`，`TCP协议是传输层协议，在传输层给数据套上TCP头(端口和序列号)`，`然后再在网络层使用IP网际协议给数据再套上IP头(IP地址)`，然后就可以发送到网络了
* 所以说，HTTP请求的第一步就是和服务器建立起TCP连接，而TCP连接需要IP协议提供的IP地址和TCP协议提供的端口，然后就可以和服务器建立TCP连接了
* 而IP地址和端口号从哪里得到？
* `我们发起HTTP请求的时候会有一个URL，URL中就包含了Ip地址和端口号`
---
* 如果URL中没有没有指明IP地址，那么我们会使用`DNS域名系统(进行域名解析时使用udp协议)`来映射获取对应的IP地址，另外DNS还有缓存服务(映射过的地址会被保存)
* 端口号的话，HTTP请求默认为80端口，HTTPS请求默认为443端口
4. 等待TCP队列
* 获得了IP地址和端口号，那么可以建立TCP连接了？
* 不，在Chrome中有一个机制，同一个域名最多同时有6个TCP链接，如果在同一个域名下同时有10个请求发生，那么剩下的4个请求会进入排队等待状态，甚至进行中的请求完成
5. 建立TCP连接
* 在排队等待结束之后，就可以通过三握手建立TCP连接了
6. 发送HTTP请求
* 一旦建立了TCP连接，浏览器就可以和服务器进行通信了
---
* 首先浏览器会向服务器发送请求行，请求行包括请求方式，请求URI，HTTP版本协议
* 发送请求行之后，还会通过请求头发送其他信息，例如cookie,浏览器版本等
* 如果请求方式是post,最后还会通过请求体发送数据给服务器

`服务器端处理HTTP请求流程`
1. 返回请求
* 一旦服务器处理完请求，就可以给浏览器返回数据了
* 首先服务器会返回响应行，包括HTTP协议版本，状态码
* 然后会给浏览器发送响应头，响应头包含了服务器自身的一些信息，比如返回的数据格式，服务端要在客户端保存的cookie信息
* 最后就可以发送响应体的数据了，通常来说，`响应体就包含了HTML的实际内容`。
2. 断开连接
* 一般来说，一旦服务器端向客户端返回了请求数据，那么它就要关闭TCP连接。但是如果`浏览器或者服务器`在其头信息中加入了`Connection:keep-alive`
* 那么`TCP连接在发送后依旧保持打开状态`，这样浏览器就可以通过同一个TCP连接发送请求
* `保持TCP连接可以省去下次请求时需要建立连接的时候，提升资源加载速度`，如：`如果一个web页面中的图片都来自同一个web站点，那么加了keep-alive就可以持久化连接，可以复用连接来请求其他资源，而不需要再重新建立新的TCP连接`
3. 重定向
* 例子:`在网址中输入geekbang.org,然后回车，结果返回的响应头中的location为https://www.geekbang.org/，状态码为301，表示永久被重定向到该网址了`
* `但是301这种永久重定向需要在服务器端设置重定向地址，否则不会发生重定向的`


## 说一下http和https
* http和https都是应用层的协议。`但是https的ssl是在传输层实现的`
* http是在客户端和服务器端进行请求和应答的标准，即使https协议兴起，http协议依旧是最广泛的协议。http协议也被称为超文本传输协议，可以让服务器传输文本到浏览器端。
* 而https协议是在http协议基础上再增加一层SSL层的协议，SSL层也称为安全层，https协议是安全的，因为该协议传输的数据是加密的，而http传输的数据是不加密的，是明文。
* https协议的工作原理是:首先浏览器向服务器发送请求，该请求是https协议，服务器知道这是https协议，需要ssl层，因此需要传递自己的公钥给客户端；服务器端传递自己的公钥给浏览器，浏览器得到公钥之后，就用公钥去加密自己的密钥，并把加密好之后的密钥发送给服务器端，服务器就使用自己的私钥去解密密钥，得到浏览器的密钥，这个时候，浏览器和服务器之间就可以进行安全的请求和应答了。
* http和https协议的区别：
1. https协议比http协议安全，因为https协议使用了加密的方式，第三方获取，修改数据的成本增加了，而http没有加密；
2. http没有加密，但是https花费在加密上的时间较长，所以http更方便；
3. https协议虽然安全，但是ca证书需要钱的，所以http协议更便宜；
4. http协议使用的是80端口，https使用的是443端口；
---
* http协议的两个特点:
1. http协议是无连接的，`每次连接都只处理一个请求，在服务器端处理完客户端的请求之后就会断开连接，所以节省了传输时间`，之后即使是同样的资源也需要重新请求
2. 由于无连接特点的存在，http协议还存在无状态的特点，也就是每次连接都不会保存上一次连接的状态，例如登录状态，通俗来说就是`没有记忆能力`，而cookie就是对http记忆能力的补充

## https
* `https就是一种通过计算机网络进行安全通信的传输协议，经由http进行通信，利用SSL/TLS建立全信道，加密数据包`
* `https使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐式和完整性`
* `ssl层位于http应用层和tcp传输层中间，ssl只保证安全，不保证可靠(消息是否送达)`
* https采用的是非对称加密算法(`证书验证阶段`)+对称加密算法(`数据传输阶段`)来保证数据安全
---
1. `证书验证阶段`
1.1 浏览器发起https请求
1.2 服务器返回https证书
1.3 客户端验证证书是否合法，如果不合法则提示告警(`很多浏览器左上角提示不安全`)
2. `数据传输阶段`
2.1 当证书验证合法后，在本地生成随机数
2.2 通过公钥加密随机数，并把加密后的随机数传输到服务器端
2.3 服务器端通过`私钥对随机数进行解密`
2.4 服务器端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输
2.5 最后浏览器根据自己保存的随机数进行解密获取数据
---
* `浏览器只有公钥，服务器有公钥和私钥！(如果浏览器也有私钥，那就不安全)`
* 为什么数据传输使用的是对称加密？
* `因为非对称加密的加解密效率低；因为只有服务器保存了私钥，只能进行单向的加解密，所以使用的是对称加密`

## http状态码
* `1xx临时请求`,表示是临时请求并请求已经被接受，`需要继续处理`
* 100:请求者应该继续提出请求
* 101:请求者要求服务器切换协议，并且服务器已经确认并且准备切换协议
---
* `2xx表示已经成功处理了请求的代码`
* 200：服务器已经`成功处理(客户端已经接受到请求后的资源)`了请求，并且这一般指的是服务器提供了请求的网页
* 201：表示的是服务器已经接受到请求，并且`成功创建资源（资源还没发给客户端）`
* 202:服务器已经接受到了请求，但是还没有进行任何处理(`资源都还没创建`)
* 203:服务器成功处理了请求，但是客户端接收到的`返回的内容可能来自于其他服务器`(`这就是非授权信息`)
* 204:服务器成功处理了请求，但是`不返回任何实体内容`
* 205:服务器同样成功处理了请求，而且不返回任何实体内容，但是和204不同的在于，205状态码需要重置文档视图(`如填写密码表单失败后清孔密码要求重新输入`)
* 206::服务器已经成功处理了部分get请求，用于迅雷中的`断点续传功能`中，实现文件分段同时下载
---
* `3xx重定向,表示我们如果要继续完成请求的话需要进行进一步的操作`
* 300:被请求的资源有`一系列可供选择的回馈信息`,这些信息每一个都有自己特定的url地址，浏览器或者客户端可以选择地址进行重定向
* 301:被请求的资源已经`被永久迁移到一个新地址`了，将来任何对该资源的引用都应该使用本次响应返回的url地址之一
* 302:请求的资源现在临时从不同的url响应请求，但是这样的重定向是临时的,`客户端应该继续向原有地址发送请求`.
* 304:已经发送了一个带条件的get请求,并且请求已经被允许,`但是文档的内容并没有被改变`。
* 305:被请求的资源`必须经过代理才可以访问`。
---
* `4xx 客户端错误`
* 400`bad request`:一:`语义有误`，不被服务器所识别，需要修改;二:`请求参数有误`
* 401`unauthorized`:当前请求需要`用户验证`。该`响应`必须包含一个适用于被请求资源的` WWW-Authenticate 信息头`用以`询问用户信息`。客户端可以重复`提交`一个包含恰当的` Authorization 头信息`的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着`服务器验证已经拒绝了那些证书`.
* 403`forbidden`:服务器已经接受到请求，但是`拒绝执行`，而且和401不同，`身份验证不起作用`。403错误和404错误不同，`403错误希望说清楚拒绝执行的原因`。
* 404`not found`:请求失败，`没有在服务器发现所需的资源`(但是不想说清楚为何拒绝执行请求的时候也可以用)。而且这个失败是永久的还是暂时的不确定.404这个状态码被广泛应用于当服务器`不想揭示到底为何请求被拒绝`或者没有其他适合的响应可用的情况下。
* 405:`请求行中指定的请求方法不能用于请求相应的资源`。
* 406:请求的资源的`内容特性不满足`请求头的要求。
* 407:和401状态码一样需要进行`身份验证`，不同的是需要在`代理服务器`中进行。
---
* `5xx服务端错误:服务器在处理请求的过程中有错误或者异常情况发生，也有可能是服务器意识到当前的软硬件资源无法完成对请求的处理`
* 500:服务器遇到了从未预料到的错误，导致它无法完成请求
* 501:服务器不支持当前请求所需要的某个功能
* 503:由于临时的`服务器维护或者过载`，服务器无法处理当前请求，这个状态是临时的，会给出预计时间Retry-After ，如果没有给出，那么可以发送500状态码
* 
* 小应用:通过 XMLHttpRequest更新以下元素，即通过div显示状态  `<div id="statusCode"></div>`
*`var myDiv = document.getElementById ("statusCode"); myDiv.innerHTML = req.status;`

## http2.0的优点(大幅度提高了web性能，减少了网络延迟)
1. 多路复用
2. 服务器端推送(`在服务器端知道客户端可能需要某个资源的时候，在客户端请求之前就把该资源发给了客户端`)
3. 头部压缩
4. 单一长连接

## 常见的HTTP方法
1. GET:获取资源
2. POST:发送资源
3. DELETE:删除服务器资源
4. `PUT:把客户端的数据存储到一个命名的服务器资源中`
5. `HEAD:仅发送命名资源响应中的首部`
6. `OPTIONS请求是浏览器知道某个POST请求或者其他请求有可能对服务器数据产生影响时发起的预检请求，如果服务器允许请求才会继续那个请求`
