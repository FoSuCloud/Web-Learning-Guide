## 伪元素选择器
1. last-child选择器是选择父元素的最后一个元素的所有xx元素，不好用。。
2. `一般来说，想要选择同名元素中的最后一个，就这样使用`
```
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
</div>

//这样就可以选中最后一个class类名为a的元素啦！
//需要注意的是，.a元素必须是某元素中的子元素，不能是根元素
.a:last-child{
	color: red;
}
```
3. 第二种情况
```
<div id="one">
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
			</div>
			<div class="a">3</div>
		</div>
//此时是2,3都变色，因为他们都是各自父元素的最后一个.a类名的元素
```
4. nth-child(n)选择第n个元素
```
		<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//红
			<div class="a">3</div>
		</div>
		//选择第二个.a元素
		.a:nth-child(2){
			color: red;
		}
```
5.nth-child(2n)选择偶数元素
```
	//只选择偶数的.a元素，奇数的话选择(2n-1)
	.a:nth-child(2n){
		color: red;
	}
	<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
			<div class="a">1</div>//red
			<div class="a">2</div>
			<div class="a">3</div>//red
		</div>
	//需要注意的是，始终是针对一个父元素来说的
	<div id="one">
		<div class="a">1</div>
		<div class="a">2</div>//red
		<div class="a">3</div>
		<div>      //因为父元素不同，所以计数的索引重新开始
			<div class="a">1</div>
			<div class="a">2</div>//red
			<div class="a">3</div>
		</div>
	</div>
```
6. nth-child(n+3)表示是从第三个开始之后的所有元素(包括第三个)
```
.a:nth-child(n+3){
	color: red;
}
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>//red
			<div class="a">1</div>//red
			<div class="a">2</div>//red
			<div class="a">3</div>//red
		</div>
```
7. nth-child(-n+3),=>3,2,1,0,-1....(0之后的都不算),所以指代1开始到3的元素
8. nth-last-child(2),选择倒数第二个元素
9. `如何选择某个父元素下最后一个xx元素呢？`
```
//通过子选择器指定某个父元素下的子元素，然后通过last-child指定该父元素下的最后一个xx子元素
.two .a:last-child{
				color: red;
			}
			
<div id="one">
			<div class="a">1</div>
			<div class="a">2</div>
			<div class="a">3</div>
			<div class="two">
				<div class="a">1</div>
				<div class="a">2</div>
				<div class="a">3</div>
			</div>
		</div>
```

## a标签链接
1. 锚点链接:`在一个文件可以定义多个锚点，点击a链接可以跳转到锚点所在位置`
```
<div id="one">
			<div class="d" id="t">2</div>
			<div class="two" style="height: 2000px;">
				<div class="a">1</div>
			</div>
			<a href="#t">ww</a>
		</div>
```
* `需要注意的是，锚点定位要使用id,使用class无效；并且要在页面高度足够滚动的时候才能看出效果`
2. 功能性链接:`点击链接可以跳转到外部文件或者启动其他程序`
3. 双向定位:(文件之间，文件两处地方都可以双向定位)
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="#w" id="t">双向定位</a> //可以从这里跳转到本文件的#w处
			</div>
			<a href="#t" id="w">ww</a>//可以从这里跳转到本文件的#t处
```
4. 单向定位
```
<div class="two" style="height: 2000px;">
				<div class="a">1</div>
				<a href="one.html#w" id="t">单向定位</a> //可以跳转到某文件的某个锚点处
			</div>
```
5. [参考](https://blog.csdn.net/cccdf_jjj/article/details/80930148)

## opacity继承的问题(父元素设置透明度，子元素必定继承！)
1. 遇到的实际问题:父元素设置圆角背景透明度，子元素是黑体字，但是子元素因为父元素是白色0.5透明，所以子元素也变得透明，此时的黑是模糊的黑！
2. 原因:`如果父元素设置了opacity属性，那么子元素必定会继承！`
3. 解决方法：
```
1. 使用rgba()来代替opacity，rgba也能设置透明度，但是不会被子元素继承，
2. 失败:对子元素使用z-index:2,尝试提高子元素优先级(提高了优先级，但是不会影响到继承问题)，但是子元素依旧继承父元素透明度，失败！
3. 失败:对子元素使用opacity:1,虽然对子元素设置样式的优先级高于继承的优先级，但是子元素的opacity:1也是基于父元素的opacity来设置的，所以依旧是低于预期效果(可以进一步在父元素opacity的基础上降低透明度，但是提高是没办法的)

```

## canvas
1. 实际应用:`在小程序中制造分享海报的时候需要用到canvas自己画图，想到做app也需要，所以学了一下js的canvas`
```
<div>
			<canvas id="one" width="600" height="600"></canvas>
			<img src="one/3.jpg" id="two">
		</div>

function draw(){
				var canvas=document.getElementById('one');
				if(!canvas.getContext) return;
				var can=canvas.getContext('2d');
				// canvas对于每个图形的起点都是0,0,即使指定起点,也是相对位置,所以图形都需要指定相对坐标
				can.beginPath(); //每创建一个图形都要开始一个路径
				// can.arc(100,100,50,0,Math.PI/2,false);
				can.strokeRect(50,50,50,50);//该方法可以绘制矩形,不需要使用stroke
				can.fillStyle='rgb(153,153,153)'
				
				can.beginPath();
				can.font='20px sans-serif';//字体样式要设置在文本之前,否则无效
				can.strokeText('我在下遗憾',50,150);//绘制的是文本边框
				can.fillText('我在下遗憾',50,200);//绘制文本
				// can.closePath();//从起始点到当前点画线,有点多此一举!
				// can.stroke();//通过线条来绘制图形轮廓
				
				can.beginPath();
				var img=document.getElementById('two');
				//必须在图片加载完再绘制图片,否则会失效
				img.onload=function(){
					can.drawImage(img,50,250,100,100);
				}
				
				can.beginPath();
				var img2=new Image();//可以自己创建一个图片元素
				//指定一个src属性
				img2.src='https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture'
				img2.onload=()=>{
					can.drawImage(img2,50,400,100,100)
				}
			}
			draw()

```
* 弧度和度数换算:`1度=PI/180*弧度`，`需要注意的是cancas中绘制图形使用的是弧度`
* [强烈推荐](https://blog.csdn.net/u012468376/article/details/73350998)

## js动态类型语言
1. `静态类型语言在编译时便确定变量的类型`
2. `动态类型语言在编译结束之后，在程序运行，变量被赋予某个值之后，才具有某个类型`
3. `JavaScript是动态类型语言`

## js的多态
1. 多态:`给不同对象发送同一个命令，不同对象会做出不同的操作，给出不同的反馈`
2. 通俗来说:`导演说action,演员开始演戏，摄影师开始拍，龙套在后台在准备，虽然是同一个命令，但是不同对象会有不同的反应`
```
			var makeSound=function(Animal){
				//	instanceof用于指出某对象是否是特定对象的实例,在此时就是判断是否存在该函数
				if(Animal.sound instanceof Function){
					Animal.sound();//执行不同的对象的同一个方法,得到不同的反馈
				}
			}
			
			var cat=function(){};
			cat.prototype.sound=function(){
				console.log('喵喵喵')
			};//使用prototype,该cat函数的实例对象的__proto__属性就可以指向sound方法
			
			var dog=function(){}
			dog.prototype.sound=function(){
				console.log("汪汪汪")
			}
			
			makeSound(new cat());
			makeSound(new dog());
			//此时如果想再添加一个对象chicken就只需要创建函数及sound函数就可以了,调用makeSound就可以实现多态
			//调用不同的对象的sound方法可以得到不同的反馈
			var chicken={
				sound:function(){
					console.log('咕咕咕')
				}
			}
			makeSound(chicken);//再创建一个chicken对象，给该对象添加sound方法

```
* 与java不同，Java是静态类型语言，需要在使用之前指定对象类型，那么该命名为dog/cat?都不同，应该给他们添加一个超类型animal,dog/cat extends animal 这样就可以实现多态了！
* `多态的最根本好处就在于可以把过程化的条件语句(if dog,else if cat...)转换为对象的多态特性，不必询问对象类型，只要对象具有该行为，那么只管调用该行为就可以了`

## js的封装
1. `一般来说，js的封装指的是将信息隐藏，封装数据和封装实现，还可以封装类型和封装变化`
2. 在java这些语言中，通过public private关键字设置访问权限实现对数据的封装特性
3. 在JavaScript中没有提供对这些关键字的支持，我们只能通过依赖变量的作用域来实现封装特性，并且只能模拟出public,private特性
```
			var one=(function(){
				var name='sada';//相当于private私有变量
				return {
					getName:function(){  //相当于public公有方法
						return name;
					}
				}
			})();
			console.log(one.getName());//通过公有方法访问到私有变量
			console.log(one.name);//不能直接访问到私有变量
```
4. 想办法把程序中变化的部分封装好之后，剩下的就是稳定而可复用的部分了

## 设计模式之一(原型模式)--实现继承
1. `原型模式是一种用于创建对象的模式，如果我们想创建一个对象，那么一般先指定对象类型，然后通过类来创建这个对象`
2. `原型模式不再关心对象的具体类型，而是找到一个对象，通过克隆的方式来创建一个一模一样的对象`
3. `如果需要一个跟某个对象一模一样的对象，那就可以使用原型模式；但是使用原型模式需要注意该语言是否提供了克隆的方法，javascript中就是Object.create方法`
```
			var one=function(){
				this.name='one';
				this.age=22;
			}
			var two=new one();
			console.log(two);
			two.name='two';
			two.age=11;//改变实例的属性
			console.log(two);
			//通过Object.create方法克隆一个和two实例一模一样的对象
			var two_child=Object.create(two);
			console.log(two_child);//two_child.__proto__指向two
			// 有些浏览器可能不支持Object.create方法,则使用
			Object.create=Object.create||function(obj){
				var F=function(){};
				F.prototype=obj;// 所以使用Object.create方法克隆其实就是创建一个对象指向obj,然后返回该对象的实例,由于该实例没有重新定义属性方法,所以自然寻找不到,就会通过__poto__属性往上查找到two对象,也就实现了克隆
				return new F();
			}
```
4. 原型模式同时也是一种编程范式，也存在原型编程的基本规则
* 1.所有书都是对象(但是在js中存在基本数据类型，所以js是绝大数是对象，但是所有对象都存在一个根对象，所有的对象都可以通过__proto__追溯到该对象)
```
			var one=new Object();
			// Object.getPrototypeOf()方法可以获取到对象的原型
			console.log(Object.getPrototypeOf(one));
			console.log(Object.getPrototypeOf(one)===Object.prototype);//true
			// 也就表明了通过new Object()得到的one实例的原型是Object.prototpe 
			// 并且js中所有的对象的原型(或者是最终原型指向)都是Object.prototype
```
* 2.要得到一个对象，不是通过实例化类，而是通过找到一个对象作为原型并克隆它
* `但是js一般不是通过new来创建对象吗？的确是，但是new运算符来调用函数时，此时的函数就是一个构造器`
* `使用new运算符来创建对象的过程其实就是先克隆Object.prototpe对象，然后再通过一些操作来进行克隆的过程`
* 3.对象会记住他的原型(`通过__proto__隐藏属性`)
* `每个对象的__proto__属性默认会指向它的构造器对象，也就是{Construtor}.prototype`
* 注意:不是所有浏览器都会公开__proto__属性
```
			var one=new Object();
			console.log(one.__proto__===Object.prototype);//true
			
			var Person=function () {};
			//修改obj对象的__proto__指向
			one.__proto__=Person.prototype;
			console.log(one.__proto__===Person.prototype);
```
* 4.如果对象无法响应某个请求，那么它会把该请求委托给它的构造器的原型，直到要一个可以处理该请求的对象为止
* `虽然在js中，每个对象的原型都是Object.prototype,但是通过修改__proto__指向可以改变对象原型`
```
//闭包封装
			var one=(function(){
				return {
					getName:function (name){
						return name;
					}
				}
			})();
			var one_child=function(){};
			// var one_child_child=new one_child();
			// console.log(one_child_child.getName('yiyi'));//往上找getName()方法,但是不存在
			
			one_child.prototype=one;//修改one_child原型指向为one函数
			var one_child_child=new one_child();
			console.log(one_child_child.getName('dsa'));//改变原型后,可以往上找到方法,这也就是继承,也就是原型链
```
* `任何对象，除了Object.prototype之外，都会有原型，而通过Object.create(null)可以创建出没有原型的对象`

## 强制类型转换
```
			// 强制类型转换 Number
			console.log(Number('2'));//2
			console.log(Number(null));//0
			console.log(Number(undefined));//NaN
			console.log(Number(NaN));//NaN
			console.log(Number([]));//0
			console.log(Number({}));//NaN
			
			// 强制类型转换String(相当于调用了 xx.valueOf().toString())
			console.log(String(1));//'1'
			console.log(String([])==='');//'',true,空数组被强制转换为''空字符串
			console.log(String({}));//object Object 
			console.log(String(undefined));//undefined
			console.log(String(null));//null
			console.log(String(NaN));//NaN
			// 这也从侧面解释了为什么 null==0是 false,因为关系运算符是把数据先转换为字符串的,也是调用valueOf().toString()方法
			
			// 强制类型转换 Boolean
			console.log(Boolean(1));//true
			// 强制转换为Boolean,除了'',0,NaN,undefined,null,false之外,其他的都会转为true
			console.log(Boolean([]));//true
			console.log(Boolean({}));//true
```