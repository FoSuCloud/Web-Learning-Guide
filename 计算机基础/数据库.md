## sql查询优化
1. `如果有可变长的字段，那么把可变长的字段改为定长可以改进性能，因为定长的字段是很容易计算下一个数据的偏移量的，所以读取速度的自然也会很快`
2. `太过于长的列可以单独做一个表`
3. (unsigned表示非负数)

## sql语言(分为四种)
* `DQL(query,数据查询语言)`:由selectk,from,where子句组成的查询块
* `DML(manager,数据管理语言)`:有 更新，插入，删除操作
* `DCL(control,数据操纵语言)`:用于授予/回收用户权限，控制事务
* `DDL(defined,数据定义语言)`:用于创建数据库中的表，视图，索引，聚簇等

## 数据模型
1. 层次模型:`就是用树状层次结构来组织数据的数据模型`
2. 网状模型:`用有向图表示实体与实体之间的联系的数据结构模型`
3. 关系模型:`目前最流行，结构为二维表`

## 函数依赖
1. `例子；在属性x确定的情况下，可以确定属性y的值，那就是函数依赖，例如班主任确定了，班级自然也就确定了`
2. `也可以是学号一样的话，那么学生名字肯定一样，所以可以说姓名依赖于学号`
3. `而学生名字一样不一定学号一样，因为可能重名，所以不可以说学号依赖于姓名`
4. 其他函数依赖的例子:`(学号，课名)=>分数，系名=>系主任`
---
5. 部分函数依赖:`存在属性X=>属性Y,而X'是Y的真子集时，属性Y部分函数依赖于属性X`
* 例如 姓名|学号|身份证，(学号，身份证)可以确定一个唯一的名字，但是学号也可以确定唯一的名字，身份证也可以确定唯一的名字
* 所以这种情况就是部分函数依赖，`注意:部分函数依赖只有属性X是组合属性时谈论才有用，单属性肯定是完全函数依赖！`
6. 完全函数依赖:`存在属性X=>属性Y，并且X'不能确定属性Y时，是完全函数依赖`
* 如: 科目|学号|分数 ，(科目，学号)=>分数，必须科目和学号组合在一起才能有唯一的分数，只有科目或者学号有多种可能
7. `传递函数依赖：属性X确定属性Y，属性Y确定属性Z，属性X不能确定属性Z`
* 如:`学号确定宿舍，宿舍确定宿舍费，学号不能直接确定宿舍费`

## 三范式
1. `一范式：只要是能在数据库中存在的数据都符合一范式`
2. `一范式:原子性，不可分割`
* 例如学生名称，学号，班级，班主任表的班主任数据明显是重复的，可以根据班级来找到班主任表
* 如果是直接这样全部都在一个表，该表的班主任列明显是冗余，但是也是不可分割，那就是一范式
3. `二范式消除了非主属性对码的部分函数依赖，有且仅有一个主属性`
* `二范式要求表里的所有非主属性都对码有完全函数依赖！`
4. `三范式消除了非主属性对码的传递函数依赖，也就是说三范式中的非主属性不能对其他非主属性存在函数依赖`
5. [参考](https://www.cnblogs.com/rosesmall/p/9585655.html)

## 连接查询
1. `inner join：内连接，返回两个表中完全匹配的结果(如果没有完全匹配的，那么就是空)`
`写法1:select * from a inner join b on a.id=b.id`
`写法2:select * from a join b on a.id=b.id`

2. `left join 左连接，在两表连接查询时，会返回左表所有的行，即使右表中没有匹配的记录（所以返回的数组长度是左表的长度）`
`select * from a left join b on a.id=b.id`

3. `right join:在两张表进行查询时，会返回右表所有的行，即使左表没有匹配数据`

4. `full join,在两张表进行查询时，会返回左表和右表中没有匹配的行`
* MySQL中并`没有直接支持FULL JOIN语法`，但可以使用其他方式模拟实现FULL JOIN的效果。
* FULL JOIN是一种连接查询，它返回两个表中`所有匹配和不匹配的记录`。
* 在MySQL中，可以使用LEFT JOIN和RIGHT JOIN的组合来模拟FULL JOIN。
```MYSQL
SELECT *
FROM table1
LEFT JOIN table2 ON table1.id = table2.id
UNION
SELECT *
FROM table1
RIGHT JOIN table2 ON table1.id = table2.id;
```
* 首先使用LEFT JOIN连接table1和table2，然后`使用UNION操作符将结果与使用RIGHT JOIN连接table1和table2的结果合并`。
* [参考](https://www.cnblogs.com/lijingran/p/9001302.html)

## 连接查询实例
* Person表
 PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar 

* Address表
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
* 编写一个 SQL 查询，满足条件：`无论 person 是否有地址信息`，都需要基于上述两表提供 person 的以下信息：
* `使用left join 把两个表查询到的数据关联起来(返回左表中所有的行，即使在右表没有匹配数据)`
```
select FirstName, LastName, City, State from Person left join Address on Person.PersonId=Address.PersonId
```

## 数据库事务
1. 数据库事务是构成单一逻辑工作单元的操作集合
2. 一个经典的数据库事务如下:
```
BEGIN TRANSACTION  // 事务开始
SQL1
SQL2
COMMIT/ROLLBACK 	//事务提交或者回滚
```
3. `数据库事务可以包含一个或者多个数据库操作，但是这些操作构成一个逻辑上的整体`
4. `构成逻辑整体的这些数据库操作，要么全部执行成功，要么全部不执行`
5. `构成事务的所有操作，要么全部对数据库产生影响，要么全部不产生影响，即不管事务是否执行成功，数据库总能保持一致性`
6. `以上在数据库出现故障以及并发事务的情况下依旧成立`

## 事务解决问题的实例
```
BEGIN TRANSACTION
A账户减少100元
B账户增加100元
COMMIT
```
* `当数据库崩溃时，系统能够以事务为边界进行恢复，不会出现A账户减少，而B账户未增加的情况`
* `当有多个账户同时操作数据库，数据库能够以事务进行并发控制，使多个账户对B账户的转账操作互相隔离`

## 事务的ACID特性
1. 原子性Atomicity,事务中的所有操作作为一个整体像院子一样不可分割，要么全部成功，要么全部失败
2. 一致性Consistency,事物的执行必定使数据库从一个一致性状态到另一个一致性状态
3. 隔离性Isolation,并发执行的事务不会互相影响，其对数据库的影响会跟他们串行执行时的结果一样。
4. 持久性Duration,事物一旦提交，其对数据库的更新就是持久的，任何事务或者故障都不会丢失该数据

* 个事务只能包含对一个数据库实例的数据操作，不允许跨多个数据库实例，跨多个数据库实例需要分布式事务支持
* 数据库事务会给数据库带来并发操作带来一定影响，会降低系统的并发能力
## [参考](https://www.cnblogs.com/takumicx/p/9998844.html)

## where和having的区别
* “Where”是一个约束声明，在`查询数据库的结果返回之前`对数据库中的查询条件进行约束，即在结果返回之前起作用，且where后面不能使用“聚合函数”；
* “Having”是一个过滤声明，所谓过滤是`在查询数据库的结果返回之后进行过滤`，即在结果返回之后起作用，并且having后面可以使用“聚合函数”。
* `Having用来限制分组统计结果信息的显示`

## 删除数据库中的表
1. `drop table把表的数据和结构等等删的干干净净`
2. `delete table把表的内容删除，不删除表的结构(定义还在)，而且可以加where条件`
3. `truncate table也是删除表的内容，不删除表的结构(定义)，但是不能加where`

## 数据库文件中主数据文件扩展名是.mdf(primary data file)和次数据库文件扩展名是.ndf(secondary data file)

## 在Oracle数据库的逻辑结构中,从大到小的顺序是 表空间——段——区——块

## select count语句
```
select count(*) from table 表示返回表中包括空行和重复行在内的行数,但是会扫描所有列
select count(1) from table 也是返回表中包括空行和重复行在内的行数，不会扫描所有列,1其实就是表示有多少个符合条件的行，但是此时没有where,所有没条件也就是返回总行数
select count(id) from table 表示返回表中存在该列id的行数，但是该列的值不为空，为空的不计算，所以在此题中是不能用这个，因为tg_email都为空，用主键可以，因为主键肯定不为空
select count(distinct id) from table 表示返回数据表中id该列id不一致的个数
```

## sql的模糊查询匹配模式
1. `% 表示0个或者多个字符`
2. `_表示任意单个字符！`
3. `[]匹配中括号内的某一个字符`
4. `[^]匹配不在中括号内的某一个字符`
* 例子:`WHERE LIKE '_YOU%' 可以匹配到 IYOUHAHA `
* `WHERE LIKE '[ABC]YOU[^ABC]' 匹配到 AYOUE`

## 数据关系映射
1. `球员与球队的关系是对多一`，因为多个球员属于一个球队，还有多个学生属于一个班级
2. `球队与球员的关系是一对多`，一个球队有多个球员，还有一个班级有多个学生
3. `学号与学生的关系是一对一，一个学号只有一个学生，一个学生只有一个学号`
4. `学生与选修课是多对多的关系，多个学生可以选择一门选修课，一门选修课有多个学生`

## 插入列 `alter table user add column openid varchar(200) not null;`

## 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
根据以上输入，你的查询应返回以下结果：
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```
-- // 思路是检索Email,还有根据count()获取数量，生成一个新的表，表名随便设置，然后where 查找num列元素大于1的值
select Email from (
    select Email,count(Email) as num 
    from Person
    group by Email
) as newtable
where num>1
-- 开头使用select Email是因为返回Email字段
-- ()内部使用group by可以增加检索速度
-- ()后面使用as是作为表名，去掉会报错
-- where是检索大于1的数据
```
